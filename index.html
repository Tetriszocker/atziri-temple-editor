<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Atziris Temple Planner</title>
<style>
  body {
    font-family: sans-serif;
    background: #222;
    color: #eee;
    display: flex;
	flex-direction: column;
    align-items: center; /* Sidebar oben */
    padding-top: 40px;
    min-height: 100vh;
    margin: 0;
  }
  
#editor-title {
  text-align: center;
  color: #fff;
  font-size: 28px;
  font-weight: bold;
  margin-bottom: 20px;
  margin-top: 30px;
  font-family: 'Arial', sans-serif;
}
 
#editor-container {
  display: flex;
  gap: 20px;
  justify-content: center;
  align-items: flex-start;
  margin-top: 20px;
}

/* Grid */
#grid-container { display: flex; justify-content: center; }

#grid {
  display: grid;
  grid-template-columns: repeat(9, 50px);
  grid-template-rows: repeat(9, 50px);
  gap: 12px;
  transform: rotate(45deg);
  margin-top: 120px;
  margin-right: 120px;
  
}

/* ---------------- Grid-Zellen ---------------- */
.cell {
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
	border: 1px solid #333;
    align-items: center;
	line-height: 1em;
    position: relative;
}

.cell span {
  transform: rotate(-45deg); /* Inhalt gegen Grid-Rotation drehen */
  display: block;
}

.cell-content {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
	color: #000;
	font-weight: bold;
	line-height: 1em;
	
	
}



/* Hover-Effekt f√ºr Grid-Zellen */
.cell:hover {
  transform: scale(1.05);        /* leichtes Vergr√∂√üern */
  border-color: #fff;            /* wei√üe Umrandung */
  box-shadow: 0 0 10px rgba(255,255,255,0.5); /* leichter Glow */
  transition: transform 0.1s, border-color 0.1s, box-shadow 0.1s;
}

.cell span { transform: rotate(-45deg); }

/* Sidebar */
#sidebar {
  width: 420px;
  padding: 20px;
  background: #181818;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* Aktueller Raum */
#current-room-display {
  text-align: center;
  font-weight: bold;
  font-size: 16px;
}

/* Palette */
#palette-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
}


/* Palette Buttons */
.room-palette-item {
  width: 100px;
  height: 60px;
  border: 1px solid #555;
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: flex-end;
  text-align: center;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  line-height: 1.1;
  color: #fff;
  padding: 2px;
  overflow-wrap: break-word;
  word-break: break-word;
  transition: transform 0.15s, border-color 0.15s, box-shadow 0.15s;
}

.room-palette-item:hover {
  border: 2px solid #00ff00; 
  box-shadow: 0 0 12px #00ff00; /* sanfter Glow */
  transform: scale(1.08);       /* leicht gr√∂√üer */
}


/* Effekte-Anzeige */
#effects-display {
  border: 1px solid #888;
  padding: 10px;
  min-height: 200px;
  background-color: #222;
  color: #fff;
  font-size: 12px;
  overflow-y: auto;
}

#big-a {
  position: absolute;
  font-size: 60px;
  font-weight: bold;
  color: red;
  pointer-events: none;
  transform: translate(-50%, -50%); /* Zentrum des A */
}

.no-power {
  filter: grayscale(100%);
  opacity: 0.5;
}

.generator-edge {
  position: relative;
  z-index: 1;
}

.generator-edge::before {
  content: "";
  position: absolute;
  inset: -2px;
  border-radius: 4px;
  background: linear-gradient(
    90deg,
    transparent 0%,
    rgba(143, 202, 242, 0.0) 20%,
    rgba(143, 202, 242, 1.2) 50%,
    rgba(143, 202, 242, 0.0) 80%,
    transparent 100%
  );
  background-size: 300% 300%;
  animation: energyRun 2.2s linear infinite;
  pointer-events: none;
  mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  mask-composite: exclude;
  -webkit-mask-composite: xor;
  padding: 3px;
}

@keyframes energyRun {
  from { background-position: 0% 50%; }
  to   { background-position: 300% 50%; }
}

/* Palette links, Buttons rechts */
#palette-and-buttons {
  display: flex;
  align-items: flex-start;
  gap: 14px;
}

 /* Button-Spalte */
#palette-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* Buttons wie echte Buttons */
#palette-buttons button {
  padding: 10px 14px;
  background: #2b2b2b;
  color: #fff;
  border: 1px solid #555;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  transition: background 0.15s, box-shadow 0.15s, transform 0.1s;
}

#palette-buttons button:hover {
  background: #3a3a3a;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

#palette-buttons button:active {
  transform: translateY(1px);
}


/* Button-Spalte */
#palette-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#palette-wrapper {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#palette-top-buttons {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
}

.palette-btn {
  padding: 8px 0;
  background: #2b2b2b;
  color: #fff;
  border: 1px solid #555;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.15s, box-shadow 0.15s;
}

.palette-btn:hover {
  background: #3a3a3a;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

.room-palette-item.active {
  border: 2px solid #00ff00;   /* leuchtendes Gr√ºn */
  box-shadow: 0 0 8px #00ff00; /* Glow-Effekt */
  transform: scale(1.05);      /* leicht vergr√∂√üern */
}

/* Upgrade Tooltip States */
.upgrade-ok {
  color: #4caf50; /* gr√ºn */
  font-weight: 600;
}

.upgrade-missing {
  color: #aaa;
}

.upgrade-title {
  margin-top: 6px;
  font-weight: bold;
  font-size: 12px;
}

.cell::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 70px;
  left: 50%;
  transform: translateX(-50%) rotate(-45deg);
  background: #111;
  color: #fff;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 11px;
  line-height: 1.3;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  z-index: 100;
  box-shadow: 0 0 10px rgba(0,0,0,0.8);
}

.cell:hover::after {
  opacity: 0;
}

#room-tooltip {
  position: fixed;
  background: #111;
  border: 1px solid #555;
  border-radius: 8px;
  padding: 10px 12px;
  font-size: 12px;
  color: #fff;
  pointer-events: none;
  z-index: 1000;
  max-width: 260px;
  box-shadow: 0 0 14px rgba(0,0,0,0.9);
  opacity: 0;
  transition: opacity 0.12s ease;
  
}

#room-tooltip strong {
  font-size: 13px;
}

#room-tooltip .upgrade-ok {
  color: #4caf50;
  font-weight: 600;
}

#room-tooltip .upgrade-missing {
  color: #aaa;
}

#room-tooltip .upgrade-title {
  margin-top: 6px;
  font-weight: bold;
  font-size: 12px;
  color: #fff;
}

.room-palette-item {
  display: flex;
  flex-direction: column; /* Stackt Name und Buttons vertikal */
  align-items: flex-end;    /* Zentriert alles horizontal */
  justify-content: center; 
  padding: 4px;
  text-align: center;
  position: relative;
}

.room-palette-item .tier-buttons {
  display: flex;
  gap: 4px;
  margin-top: 6px; /* Abstand unter dem Namen */
}


/* ----------------------------- */
/* Br√ºcken */
.bridge {
  position: absolute;
  background-color: #00ff00;
  display: none; /* standardm√§√üig unsichtbar */
  z-index: 1;
  border-radius: 2px;
  opacity: 0;
}

/* Aktivierte Br√ºcken */
.bridge.active {
  opacity: 1;
  display: block;
}

/* Richtung Up */
.bridge.up {
  width: 6px;
  height: 12px; /* halbe Gap-H√∂he */
  top: -12px;
  left: 50%;
  transform: translateX(-50%);
}

/* Richtung Down */
.bridge.down {
  width: 6px;
  height: 12px;
  bottom: -12px;
  left: 50%;
  transform: translateX(-50%);
}

/* Richtung Left */
.bridge.left {
  width: 12px; /* halbe Gap-Breite */
  height: 6px;
  left: -12px;
  top: 50%;
  transform: translateY(-50%);
}

/* Richtung Right */
.bridge.right {
  width: 12px;
  height: 6px;
  right: -12px;
  top: 50%;
  transform: translateY(-50%);
}

.mode-switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
  margin-right: 10px;
}

.mode-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #555;
  transition: 0.4s;
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: #fff;
  transition: 0.4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

/* -------------------- Info Box Styling -------------------- */
#info-box-container {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#toggle-info-btn {
  background: #2b2b2b;
  color: #fff;
  border: 1px solid #555;
  border-radius: 6px;
  padding: 6px 12px;
  font-size: 13px;
  cursor: pointer;
  font-weight: 600;
  margin-bottom: 4px;
}

#toggle-info-btn:hover {
  background: #3a3a3a;
}

#info-box {
  background: #181818;
  color: #eee;
  border: 1px solid #555;
  border-radius: 6px;
  padding: 10px;
  font-size: 12px;
  line-height: 1.4;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
  opacity: 0;
}

#info-box.expanded {
  max-height: 300px; /* genug Platz f√ºr Inhalt */
  opacity: 1;
}


.room-palette-item {
  display: flex;
  flex-direction: column;
  justify-content: flex-end; /* ‚¨Ö Text nach unten */
  align-items: center;
  position: relative;
}

.room-palette-item > div {
  color: white;              /* ‚¨Ö Text wei√ü */
  font-size: 14px;
  text-align: center;
  padding-bottom: 1px;       /* ‚¨Ö Abstand zum unteren Rand */
  pointer-events: none;
}


	<!--CSS -->
 
</style>
</head>
<body>

 <h1 id="editor-title">PoE2 Atziri's Temple Planner - Tetriszocker</h1>
 
 <div id="mode-switch-container" style="text-align:center; margin-bottom:10px;">
  <label class="mode-switch">
    <input type="checkbox" id="modeToggle">
    <span class="slider"></span>
  </label>
  <span id="mode-info" title="Ingame Logic active">
    Ingame Logic used
  </span>
</div>

 
 <div id="editor-container">
  <!-- Grid links -->
  <div id="grid-container">
    <div id="grid"></div>
	
  </div>
  


  <!-- Sidebar rechts -->
  <div id="sidebar">
  
  <div id="info-box-container">
  <button id="toggle-info-btn">‚Ñπ Info</button>
  <div id="info-box" class="collapsed">
    <p>
      Welcome to the Atziri Temple Planner!<br>
      - You can switch the placement mode via the switch above the grid.<br>
      - The ingame mode uses the ingame placement ruleset.<br>
      - You can click a tile and it shows you where you can place it via a green box.<br>
      - Manuel mode allows you to ignore the placement rules and just follows the ingame upgrade rules. <br>
	  - If you cannot place anything, reset your grid so the first Path gets autoplaced. <br>
	  - Medallion can be used on any tile to increase its Tier. This will currently brick the upgradelogic for some tiles and should only be used for your overview. <br>
	  - First time coding something so no garantuees that this is 100% correct. If you find a bug, please use this reddit thread to post it or give your feedback. <br>
	  - Most importantly: Have fun and stay sane exiles!<br>
    </p>
  </div>
</div>
    <!-- Aktueller Raum -->
    <div id="current-room-display"></div>

	<div id="palette-and-buttons">

  <!-- PALETTE -->
  <div id="palette-wrapper">

   
    <!-- Deine bestehenden Raum-K√§stchen -->
    <div id="palette-container"></div>

  </div>

  <!-- FUNKTIONSBUTTONS -->
  <div id="palette-buttons">
    <button id="reset-button">Reset Grid</button>
    <button id="save-button">üíæ Save Layout</button>
    <button id="load-button">üìÇ Load Layout</button>
    <button id="export-button">üì§ Export as URL</button>
	

  </div>

</div>

    <!-- Effekte-Anzeige -->
    <div id="effects-display">
      <h3>Room Effects</h3>
      <div id="sidebar-content"></div>
    </div>
  </div>
  
  <div id="big-a">A</div>
  
</div>

<div id="room-tooltip"></div>
<script>
    // ------------------------------
// Mapping f√ºr Anzeige der Tier-Namen in Sidebar und Tooltip
const TIER_DISPLAY_NAME = {
  tier1: 'Tier 1',
  tier2: 'Tier 2',
  tier3: 'Tier 3',
  tier4: 'Transcendent 2',
  tier5: 'Transcendent 3',
  tier6: 'Legion 2',
  tier7: 'Legion 3'
};


function nextTier(tier) {
  const n = parseInt(tier.replace('tier',''));
  if (n >= 7) return null; // maximale Tierstufe erreicht
  return 'tier' + (n + 1);
}
// 1Ô∏è‚É£ ROOM_DATA (gek√ºrzt als Beispiel, alle 59 R√§ume k√∂nnen hier eingef√ºgt werden)
  // ------------------------------
  const ROOM_DATA = {
  // -------------------------
  // 1. Path
path: {
    id: 'path',
    name: 'Path',
    color: '#cccccc',
    tooltip: 'A simple path tile with no effects.',
    variants: {
      tier1: { effects: [] }
    },
    upgrades: {},
    //upgradeInfoFunction: (cellObj) => "No upgrades available"
},
  // -------------------------
  // 2. Garrison Group
  guardhouse: {
    id: 'guardhouse',
    name: 'Garrison',
    color: '#f28c8c',
    tooltip: 'Increased number of Monster Packs',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconGarrison.webp' ,
	transcendentIcon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconTranscendentBarracks.webp',
    legionIcon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconViperLegionBarracks.webp',
    variants: {
      tier1: { effects: ['10% increased number of Monster Packs'] },
      tier2: { effects: ['15% increased number of Monster Packs'] }, // Barracks
      tier3: { effects: ['20% increased number of Monster Packs'] },
	  tier4: { effects: ['30% increased number of Magic Monsters'] },
	  tier5: { effects: ['60% increased number of Magic Monsters'] },
	  tier6: { effects: ['30% increased number of Rare Monsters '] },
	  tier7: { effects: ['60% increased number of Rare Monsters '] },		 
    },
    upgrades: {
      tier2: { type: 'adjacent', rooms: ['commanders_chamber','armoury'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['commanders_chamber','armoury'], requireAll: true },
	  
	  tier4: { type: 'adjacent', rooms: ['synthflesh_lab'], count: 1 },
	  tier5: { type: 'complex', requiredAdjacent: ['synthflesh_lab'], optionalAdjacent: ['armoury','commanders_chamber'], },
	 	  
	  tier6: { type: 'adjacent', rooms: ['spymasters_study'], count: 1 },
	  tier7: { type: 'complex', requiredAdjacent: ['spymasters_study'], optionalAdjacent: ['armoury','commanders_chamber'], },
    }
  },
  // -------------------------
  // 3. Commander Group
  commanders_chamber: {
    id: 'commanders_chamber',
    name: "Commander",
    color: '#f5a36f',
    tooltip: 'Effectiveness of Rare monsters',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconCommander.webp' ,
    variants: {
      tier1: { effects: ['Rare Monsters have 15% increased effectiveness'] },
      tier2: { effects: ['Rare Monsters have 30% increased effectiveness'] },
      tier3: { effects: ['Rare Monsters have 60% increased effectiveness'] }
    },
    upgrades: {
      tier2: { type: 'adjacent', rooms: ['guardhouse',], count: 2 },
      tier3: { type: 'adjacent', rooms: ['guardhouse',], count: 3 }
    }
  },
  // -------------------------
  // 4. Armoury Group
  armoury: {
    id: 'armoury',
    name: 'Armoury',
    color: '#f5d36f',
    tooltip: 'Effectiveness of humanoid monsters',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconArmoury.webp', 
    variants: {
      tier1: { effects: ['Humanoid Monsters have 15% increased effectiveness'] },
      tier2: { effects: ['Humanoid Monsters have 30% increased effectiveness'] },
      tier3: { effects: ['Humanoid Monsters have 60% increased effectiveness'] }
    },
    upgrades: {
      tier2: { type: 'adjacent', rooms: ['bronzeworks', 'chamber_of_souls'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['bronzeworks', 'chamber_of_souls'], requireAll: true }
    }
  },
  // -------------------------
  // 5. Smithy Group
bronzeworks: {
    id: 'bronzeworks',
    name: 'Smithy',
    color: '#fc8c6f',
    tooltip: 'Increases chest item rarity',
	icon: ' https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconSmithy.webp',
    variants: {
      tier1: { effects: ['Chests have 15% more item rarity'] },
      tier2: { effects: ['Chests have 30% more item rarity'] },
      tier3: { effects: ['Chests have 60% more item rarity'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['workshop', 'dynamo'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['workshop', 'dynamo'], count: 2 },
	}

},

  // -------------------------
  // 6. Generator Group
  dynamo: {
  id: 'dynamo',
  name: 'Generator',
  color: '#8fcaf2',
  tooltip: 'Required for Smithy, Synth Lab, Transc Barracks and 2x for Workshop Upgrades',
  icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconGenerator.webp', 
  providesEnergy: true,
  energyRangeByTier: {
    tier1: 3,
    tier2: 4,
    tier3: 5
  },
  variants: {
    tier1: { effects: ['Construct Monsters have 15% increased effectiveness'] },
    tier2: { effects: ['Construct Monsters have 30% increased effectiveness'] },
    tier3: { effects: ['Construct Monsters have 60% increased effectiveness'] }
  },
  upgrades: {
    tier2: { type: 'adjacent', rooms: ['thaumaturges_laboratory', 'altar_of_sacrifice'], count: 1 },
    tier3: { type: 'complex', requiredAdjacent: ['thaumaturges_laboratory', 'altar_of_sacrifice'], }
  }
},

  // -------------------------
  // 7. Spymaster Group
spymasters_study: {
    id: 'spymasters_study',
    name: "Spymaster",
    color: '#6fcf6f',
    tooltip: 'Increases Temple Mod effects. Upgrades by assassinating other Spymasters',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconViperSpymaster.webp', 
    variants: {
      tier1: { effects: ['8% increased effect of Temple Mods ...'] },
      tier2: { effects: ['15% increased effect of Temple Mods ...'] },
      tier3: { effects: ['30% increased effect of Temple Mods ...'] }
    },
    upgrades: {},
    upgradeInfoFunction: (cellObj) => "Spymaster upgrades by assassinating other Spymasters. For the editor, place the Spymaster then click on the desired Tier"
},
  // -------------------------
  // 9. Synthflesh Lab Group
  synthflesh_lab: {
    id: 'synthflesh_lab',
    name: 'Synth Lab',
    color: '#cf6fcf',
    tooltip: 'Increases exp gain',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconSynthflesh.webp', 
    variants: {
      tier1: { effects: ['10% inc. exp'] },
      tier2: { effects: ['20% inc. exp'] },
      tier3: { effects: ['40% inc. exp'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['surgeons_ward', 'dynamo'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['surgeons_ward', 'dynamo'], count: 2 }
	 
    }
  },
  // -------------------------
  // 10. Flesh Surgeon Group
  surgeons_ward: {
    id: 'surgeons_ward',
    name: "Flesh Surgeon",
    color: '#cf8c6f',
    tooltip: 'Effectiveness of unique Monsters',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconFleshSurgeon.webp',
    variants: {
      tier1: { effects: ['10% Unique Monster Effectiveness'] },
      tier2: { effects: ['20% Unique Monster Effectiveness'] },
      tier3: { effects: ['40% Unique Monster Effectiveness. Gives Limp Mod.'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['synthflesh_lab'], minTier: 0, count: 1 },
    tier3: { type: 'adjacent', rooms: ['synthflesh_lab'], minTier: 1, count: 1 }
	}
  },
  // -------------------------
  // 11. Golem Works Group
  workshop: {
    id: 'workshop',
    name: 'Golem Works',
    color: '#8cf2cf',
	tooltip: 'increased effect of Temple Mods from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconGolemWorks.webp', 
    variants: {
      tier1: { effects: ['8% increased effect of Temple Mods from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs'] },
      tier2: { effects: ['15% increased effect of Temple Mods from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs'] },
      tier3: { effects: ['30% increased effect of Temple Mods from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs'] }
    },
    upgrades: {  
	tier2: { type: 'adjacent', rooms: ['dynamo'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['dynamo'], count: 2 },
			  }
   },
  // -------------------------
  // 12. Alchemy Lab Group
  chamber_of_souls: {
    id: 'chamber_of_souls',
    name: 'Alchemy Lab',
    color: '#f2cf6f',
    tooltip: 'Item rarity on Monsters',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconAlchemyLab.webp', 
    variants: {
      tier1: { effects: ['15% increased item rarity'] },
      tier2: { effects: ['30% increased item rarity'] },
      tier3: { effects: ['60% increased item rarity. Corrupt Soul Cores'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['thaumaturges_laboratory'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['thaumaturges_laboratory'], count: 2 }
	}
  },
  // -------------------------
  // 13. Thaumaturge Group
  thaumaturges_laboratory: {
    id: 'thaumaturges_laboratory',
    name: "Thaumaturge's",
    color: '#6ff2cf',
    tooltip: 'Increased effect of Temple Mods from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconThaumaturge.webp' ,
    variants: {
      tier1: { effects: ['8% increased effect of Temple Mods from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers'] },
      tier2: { effects: ['15% increased effect of Temple Mods from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers'] },
      tier3: { effects: ['Area contains an additional Quadrilla Sergeant. 30% increased effect of Temple Mods from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers'] }
    },
    upgrades: {
	  tier2: { type: 'adjacent', rooms: ['altar_of_sacrifice'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['altar_of_sacrifice'], count: 2 }
	}
  },
  // -------------------------
  // 14. Corruption Chamber Group
  crimson_hall: {
    id: 'crimson_hall',
    name: 'Corruption Chamber',
    color: '#f26fcf',
    tooltip: 'Rare Monsters have a 15% chance to have an additional Modifier',
	icon:'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconCorruption.webp', 
    variants: {
      tier1: { effects: ['Rare Monsters have a 15% chance to have an additional Modifier'] },
      tier2: { effects: ['Rare Monsters have a 30% chance to have an additional Modifier'] },
      tier3: { effects: ['Area contains an additional Royal Sentinel. Rare Monsters have a 60% chance to have an additional Modifier'] }
    },
    upgrades: {
	  tier2: { type: 'adjacent', rooms: ['altar_of_sacrifice', 'thaumaturges_laboratory'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['altar_of_sacrifice', 'thaumaturges_laboratory'], count: 2 }}
  },

  // -------------------------
  // 15. Sacrificial Chamber Group
  altar_of_sacrifice: {
    id: 'altar_of_sacrifice',
    name: 'Sacrifical Chamber',
	color: '#6f6f6f',
    tooltip: 'More rare Chests',
	icon:'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconSacrificialChamber.webp',
    variants: {
      tier1: { effects: ['15% increased amount of Rare Chests'] },
      tier2: { effects: ['15% increased amount of Rare Chests'] },
      tier3: { effects: ['60% increased amount of Rare Chests. Area contains an additional Unchained Beast'] }
    },
    upgrades: {},
	upgradeInfoFunction: (cellObj) => "Upgrades by sacrificing another room."
  },
  // -------------------------
  // 16. Reward Rooms (Joker)
  joker: {
    id: 'joker',
    name: 'Reward Room',
	color: '#ffffff',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconRewardCurrency.webp',
    tooltip: 'Special reward room. No effect.',
    variants: {
      tier1: { effects: [] }
    },
    upgrades: {},
	upgradeInfoFunction: (cellObj) => "No upgrades available"
  },
     // 17. Clean Tile 
  Clean: {
    id: 'Clean',
    name: 'Clean Tile',
    color: '#111',
    tooltip: '',
	showTooltip: false,
    variants: {
      tier1: { effects: [] }
    },
    upgrades: {},
	upgradeInfoFunction: (cellObj) => "No upgrades available"
  },
  
  sealed_vault: {
  id: 'sealed_vault',
  name: "Sealed Vault",
  color: "#7a6c3a", // gold-braun, kannst du anpassen
  icon: "https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconVault.webp", // optional, falls du Icons nutzt
  tooltip: "Increases item rarity by 25%.",
  variants: {
      tier1: { effects: ['25% increased rarity of items dropped by Monsters'] },
  upgrades: {}, // ‚ùó bewusst leer ‚Üí keine Upgrades
  upgradeInfoFunction: (cellObj) => "No upgrades available"
}
}
   
};
// Liste g√ºltiger Zellen im Logic Mode
let validPlacementCells = [];

// ------------------------------
// Raum ‚Üî Code Mapping
const ROOM_CODE_MAP = {
  path: "P",
  guardhouse: "G",
  commanders_chamber: "C",
  armoury: "A",
  bronzeworks: "B",
  dynamo: "D",
  spymasters_study: "S",
  synthflesh_lab: "Y",
  surgeons_ward: "F",
  workshop: "W",
  chamber_of_souls: "L",
  thaumaturges_laboratory: "T",
  crimson_hall: "R",
  altar_of_sacrifice: "Z",
  joker: "J",
  sealed_vault: "SV",
  Clean: "_"
};

const ROOM_CODE_MAP_REVERSE = Object.fromEntries(
  Object.entries(ROOM_CODE_MAP).map(([room, code]) => [code, room])
);

const CODE_ROOM_MAP = Object.fromEntries(
  Object.entries(ROOM_CODE_MAP).map(([k, v]) => [v, k])
);

const GENERATOR_ROOMS = ['dynamo'];
 // ------------------------------
// 2. Globale Variable f√ºr aktuell ausgew√§hlten Raum
let current = ROOM_DATA['path']; 

const sidebarContent = document.getElementById("sidebar-content");
const tooltipEl = document.getElementById("room-tooltip");

let selectedCell = null; // speichert die aktuell ausgew√§hlte Zelle auf dem Grid

let placementMode = 'logic'; // 'logic' = automatische Vorschl√§ge, 'manual' = alles erlaubt
// ------------------------------
// 3. Aktueller Raum anzeigen
const currentRoomEl = document.getElementById('current-room-display');
function updateCurrentRoomDisplay() {
  currentRoomEl.innerText = current.name;
  currentRoomEl.title = current.tooltip;
}
updateCurrentRoomDisplay();
// ------------------------------
// 4. Palette erstellen
// ------------------------------
// 4. Palette erstellen
const paletteContainer = document.getElementById('palette-container');

// üîπ Zuerst den Medallion-Raum erstellen und hinzuf√ºgen
const medallionPaletteItem = document.createElement("div");
medallionPaletteItem.classList.add("room-palette-item");

medallionPaletteItem.textContent = "Medallion +1 Tier";
medallionPaletteItem.title = "Increase the Tier by 1";
medallionPaletteItem.style.backgroundColor = "#FFD700"; // z.B. gold
medallionPaletteItem.style.border = "3px solid #7c5726"; // Oranger Rand
medallionPaletteItem.style.borderRadius = "6px"; // optional: abgerundete Ecken

// Klick-Event f√ºr Medallion
medallionPaletteItem.addEventListener("click", () => {
    // Medallion als aktuell ausgew√§hlten Raum setzen
    current = { id: 'medallion', name: 'Medallion' };

    // Alle aktiven Markierungen entfernen
    document.querySelectorAll('.room-palette-item').forEach(item => item.classList.remove('active'));

    // Medallion als aktiv markieren
    medallionPaletteItem.classList.add('active');

    // Anzeige aktualisieren
    updateCurrentRoomDisplay();

    // Logic-Modus: nur g√ºltige Zellen markieren
    if (placementMode === 'logic') {
        markValidCellsForCurrent();
    }
});

// Medallion-Element der Palette hinzuf√ºgen
paletteContainer.appendChild(medallionPaletteItem);

// üîπ Jetzt die normalen R√§ume aus ROOM_DATA hinzuf√ºgen
for (const roomId in ROOM_DATA) {
    const room = ROOM_DATA[roomId];

    // Haupt-Element f√ºr den Raum erstellen
   const el = document.createElement('div');
	el.classList.add('room-palette-item');

	if (room.icon) {
    el.style.backgroundImage = `url('${room.icon}')`;
    el.style.backgroundSize = "contain";
    el.style.backgroundRepeat = "no-repeat";
    el.style.backgroundPosition = "center";
	} else {
    el.style.backgroundColor = room.color; // Fallback, falls kein Icon
	}


    // Raumname hinzuf√ºgen
    const roomLabel = document.createElement('div');
    roomLabel.innerText = room.name;
    roomLabel.style.pointerEvents = 'none'; // Label klickbar nicht
    el.appendChild(roomLabel);

    // Daten-Attribute setzen
    el.dataset.roomId = roomId;
    el.title = room.tooltip;

    // Klick-Event f√ºr normalen Raum
    el.onclick = () => {
        current = ROOM_DATA[roomId];

        // Anzeige aktualisieren
        updateCurrentRoomDisplay();
        updateGeneratorRanges();

        // Alle aktiven Markierungen entfernen
        document.querySelectorAll('.room-palette-item').forEach(item => item.classList.remove('active'));

        // Diesen Raum als aktiv markieren
        el.classList.add('active');

        // Logic-Modus: nur g√ºltige Zellen markieren
        if (placementMode === 'logic') {
            markValidCellsForCurrent();
        }
    };

    // üîπ Tier-Buttons nur f√ºr Spymaster & Sacrificial Chamber
    if (roomId === 'spymasters_study' || roomId === 'altar_of_sacrifice') {
        const tierContainer = document.createElement('div');
        tierContainer.classList.add('tier-buttons');
        tierContainer.style.display = 'flex';
        tierContainer.style.flexDirection = 'row';
        tierContainer.style.justifyContent = 'center';
        tierContainer.style.alignItems = 'center';
        tierContainer.style.width = '100%';
        tierContainer.style.marginTop = '6px';
        tierContainer.style.gap = '6px';

        ['tier1','tier2','tier3'].forEach(tier => {
            const btn = document.createElement('button');
            btn.innerText = tier.replace('tier',''); // nur ‚Äû1‚Äú, ‚Äû2‚Äú, ‚Äû3‚Äú
            btn.style.fontSize = '11px';
            btn.style.width = '26px';
            btn.style.height = '26px';
            btn.style.padding = '0';
            btn.style.lineHeight = '26px';
            btn.style.textAlign = 'center';
            btn.style.cursor = 'pointer';

            btn.onclick = (e) => {
                e.stopPropagation(); // verhindert Klick auf den Raum selbst
                if (!selectedCell) return; // keine Zelle ausgew√§hlt

                // Tier nur auf Spymaster oder Sacrificial Chamber anwenden
                if (selectedCell.room === 'spymasters_study' || selectedCell.room === 'altar_of_sacrifice') {
                    selectedCell.tier = tier;
                    selectedCell.manualTier = true; // markiert, dass Tier manuell gesetzt wurde
                    renderCell(selectedCell);       // Zelle optisch aktualisieren
                    updateEffectsSidebar();         // Sidebar-Effekte aktualisieren
                } else {
                    return; // andere R√§ume ignorieren
                }

                // Nach Tier-√Ñnderung Logic-Zellen neu markieren
                if (placementMode === 'logic') {
                    markValidCellsForCurrent();
                }
            };

            tierContainer.appendChild(btn);
        });

        el.appendChild(tierContainer);
    }

    // Raum-Element der Palette hinzuf√ºgen
    paletteContainer.appendChild(el);
}

// ------------------------------
// Hilfsfunktion: markiert g√ºltige Zellen im Logic-Modus
function markValidCellsForCurrent() {
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cellObj = grid[y][x];

            if (isValidPlacement(cellObj)) {
                cellObj.el.style.outline = '2px solid #00ff00'; // gr√ºn
                cellObj.el.style.cursor = 'pointer';
            } else {
                cellObj.el.style.outline = '';
                cellObj.el.style.cursor = 'not-allowed';
            }
        }
    }
}


// ------------------------------
// 5. Grid erstellen
const gridEl = document.getElementById("grid");
const gridSize = 9;
let grid = [];

for (let y = 0; y < gridSize; y++) {
  let row = [];
  for (let x = 0; x < gridSize; x++) {
    const cell = document.createElement("div");
cell.classList.add("cell");

const content = document.createElement("div");
content.classList.add("cell-content");
cell.appendChild(content);

    cell.dataset.x = x;
    cell.dataset.y = y;

    const bridges = {
  up: document.createElement("div"),
  down: document.createElement("div"),
  left: document.createElement("div"),
  right: document.createElement("div"),
};

bridges.up.className = "bridge up";
bridges.down.className = "bridge down";
bridges.left.className = "bridge left";
bridges.right.className = "bridge right";

Object.values(bridges).forEach(b => {
  cell.appendChild(b);
});


const cellObj = {
  el: cell,
  room: 'Clean',
  tier: 'tier1',
  manualTier: false,
  x,
  y,
  bridges
};


    // Zelle ins Grid
    gridEl.appendChild(cell);
    row.push(cellObj);

    // Tooltip Event-Listener
    cell.addEventListener("mouseenter", () => {
  const cellObj = grid[y][x];
  const roomData = ROOM_DATA[cellObj.room];
  if (!roomData) return;

  const displayTier = TIER_DISPLAY_NAME[cellObj.tier] || cellObj.tier;
  
  // Anforderungen f√ºr das n√§chste Upgrade
const next = nextTier(cellObj.tier);
let upgradeText = "No upgrades available";

// ‚úÖ zuerst pr√ºfen, ob upgradeInfoFunction existiert
if (roomData.upgradeInfoFunction) {
    upgradeText = roomData.upgradeInfoFunction(cellObj);
} 
// ansonsten bestehende room.upgrades pr√ºfen
else {
    const next = nextTier(cellObj.tier);
    if (next && roomData.upgrades?.[next]) {
        const upgrade = roomData.upgrades[next];
        if (upgrade.type === "adjacent") {
            upgradeText = `${TIER_DISPLAY_NAME[next]}: Adjacent Rooms required: ${upgrade.rooms.map(id => ROOM_DATA[id]?.name || id).join(", ")} (at least ${upgrade.count})`;
        } else if (upgrade.type === "complex") {
            upgradeText = `${TIER_DISPLAY_NAME[next]}: Requires ${upgrade.requiredAdjacent.map(id => ROOM_DATA[id]?.name || id).join(", ")}, and: ${upgrade.optionalAdjacent.map(id => ROOM_DATA[id]?.name || id).join(", ")}`;
        }
    }
}

  tooltipEl.innerHTML = `
    <strong>${roomData.name}</strong><br>
    Tier: ${displayTier}<br>
    ${upgradeText}
  `;
  tooltipEl.style.opacity = "1";
});

    cell.addEventListener("mousemove", (e) => {
      tooltipEl.style.left = e.clientX + 20 + "px";
      tooltipEl.style.top  = e.clientY - 10 + "px";
    });

    cell.addEventListener("mouseleave", () => {
      tooltipEl.style.opacity = "0";
    });

    // Klick zum Platzieren
    cell.onclick = () => placeRoom(x, y);
  }
  grid.push(row);
}

// ---------------
// Initiale Stra√üe setzen (unterste Reihe, 5. Spalte)
const startX = 4; // 0-basiert: 5. Spalte
const startY = gridSize - 1; // unterste Reihe
const startCell = grid[startY][startX];
startCell.room = 'path';
startCell.tier = 'tier1';
startCell.manualTier = false;
renderCell(startCell);


const modeToggle = document.getElementById("modeToggle");
const modeInfo = document.getElementById("mode-info");

// globaler Modus
window.manualMode = false; // Standard = Logik-Modus

modeToggle.addEventListener("change", () => {
    if (modeToggle.checked) {
        // Manueller Modus
        window.manualMode = true;
        modeInfo.textContent = "Manuel placement";
        modeInfo.title = "You can freely place rooms";
    } else {
        // Logikmodus
        window.manualMode = false;
        modeInfo.textContent = "Ingame logic used";
        modeInfo.title = "Only allowed placements possible!";
    }
});


  positionBigA();

  window.addEventListener('resize', positionBigA);

function positionBigA() {
  const bigA = document.getElementById('big-a');

  const gridRect = gridEl.getBoundingClientRect();
  const gridSize = 9;
  const cellWidth = gridRect.width / gridSize;
  const cellHeight = gridRect.height / gridSize;

  // Wir wollen es "oben rechts auf der Diagonale" platzieren
  // Das entspricht ungef√§hr etwas oberhalb der Zelle [0][4]
  const diagonalIndex = 3;

  const top = cellHeight * diagonalIndex * 0.6; // etwas oberhalb
  const left = cellWidth * (gridSize - 1 - diagonalIndex) * 1.4; // leicht rechts

  bigA.style.top = `${gridRect.top + top}px`;
  bigA.style.left = `${gridRect.left + left}px`;
}

positionBigA();
window.addEventListener('resize', positionBigA);
// ------------------------------
// Generator-Reichweite nach Tier
function getGeneratorRange(tier) {
  const t = parseInt(tier.replace('tier',''));
  return 2 + t; // Tier1 = 3 Felder, Tier2 = 4, Tier3 = 5
}
// ------------------------------
// 6. Funktion zum Setzen eines Raums in der Zelle
function placeRoom(x, y) {
  if (!current) return;
  
  const cellObj = grid[y][x];
  selectedCell = cellObj;

  // üîπ Spezialfall: Medallion
  if (current.id === 'medallion') {
      if (!cellObj.room || cellObj.room === 'Clean') return; // Medallion nur auf bestehenden R√§umen
      const oldTier = cellObj.tier;
      const next = nextTier(oldTier); // vorhandene Funktion nutzen
      if (next) {
          cellObj.tier = next;
          cellObj.manualTier = true; // markiert, dass Tier manuell gesetzt wurde
          renderCell(cellObj);
          updateEffectsSidebar();
      }
      return; // fertig, sonst nichts tun
  }

  // üîπ WENN Clean gesetzt wird ‚Üí kompletter Reset
  if (current.id === 'Clean') {
      cellObj.room = 'Clean';
      cellObj.tier = 'tier1';
      cellObj.manualTier = false;
      renderCell(cellObj);
      highlightValidCells();
      recalcAllTiers();
      updateGeneratorRanges();
      updateEffectsSidebar();
      return;
  }

  // üîπ Normaler Raum
  if (placementMode === 'logic' && !isValidPlacement(cellObj)) return;

  cellObj.room = current.id;
  cellObj.tier = 'tier1';
  cellObj.manualTier = false;

  renderCell(cellObj);
  highlightValidCells();
  recalcAllTiers();
  updateGeneratorRanges();
  updateEffectsSidebar();
}


function highlightValidCells() {
    if (placementMode === 'manual') {
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                grid[y][x].el.style.outline = '';
                grid[y][x].el.style.cursor = 'pointer';
            }   }   }
   }





// Pr√ºft, ob der aktuell ausgew√§hlte Raum hier platziert werden darf
function isValidPlacement(cellObj) {
    // ‚úÖ Manuell-Modus: R√§ume d√ºrfen √ºberall platziert werden
    if (window.manualMode) return true;

    const neighbors = getNeighbors(cellObj);

    // Joker kann √ºberall platziert werden
    if (current.id === 'joker') {
        return true;
    }

    // Clean kann nur gesetzt werden, wenn kein Nachbar auf diese Zelle angewiesen ist
    if (current.id === 'Clean') {
        return canCleanCell(cellObj);
    }

    // Bereits belegte Zellen ausschlie√üen
    if (cellObj.room && cellObj.room !== 'Clean') return false;

    // Path nur neben bestehendem Path
    if (current.id === 'path') {
        return neighbors.some(n => n.room === 'path');
    }

    // Guardhouse (Garrison)
    if (current.id === 'guardhouse') {
        const allowedNeighbors = ['path', 'commanders_chamber', 'armoury', 'synthflesh_lab', 'spymasters_study'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Commander
    if (current.id === 'commanders_chamber') {
        const allowedNeighbors = ['path','guardhouse'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Armoury
    if (current.id === 'armoury') {
        const allowedNeighbors = ['path','bronzeworks','chamber_of_souls','guardhouse']; 
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Bronzeworks (Smithy)
    if (current.id === 'bronzeworks') {
        const allowedNeighbors = ['path','workshop', 'dynamo','armoury'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Dynamo (Generator)
    if (current.id === 'dynamo') {
        const allowedNeighbors = ['path', 'bronzeworks','synthflesh_lab','workshop','thaumaturges_laboratory','altar_of_sacrifice'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Spymaster
    if (current.id === 'spymasters_study') {
        const allowedNeighbors = ['path','guardhouse'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Synthflesh Lab
    if (current.id === 'synthflesh_lab') {
        const allowedNeighbors = ['path','surgeons_ward', 'guardhouse','dynamo'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Flesh Surgeon
    if (current.id === 'surgeons_ward') {
        const allowedNeighbors = ['path','synthflesh_lab'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Alchemy Lab
    if (current.id === 'chamber_of_souls') {
        const allowedNeighbors = ['path','thaumaturges_laboratory','armoury'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Thaumaturges Laboratory
    if (current.id === 'thaumaturges_laboratory') {
        const allowedNeighbors = ['path','altar_of_sacrifice','dynamo','chamber_of_souls','crimson_hall']; 
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Golem Works (Workshop)
    if (current.id === 'workshop') {
        const allowedNeighbors = ['path','dynamo','bronzeworks'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Corruption Chamber
    if (current.id === 'crimson_hall') {
        const allowedNeighbors = ['path','altar_of_sacrifice', 'thaumaturges_laboratory'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }

    // Sacrificial Chamber
    if (current.id === 'altar_of_sacrifice') {
        const allowedNeighbors = ['path', 'dynamo', 'crimson_hall', 'thaumaturges_laboratory'];
        return neighbors.some(n => allowedNeighbors.includes(n.room));
    }
	
	// Sealed Vault
	if (current.id === 'sealed_vault') {
    const neighbors = getNeighbors(cellObj);
    return neighbors.some(n => n.room === 'path');
}


    // Alle anderen R√§ume: pr√ºfen, ob Upgrade √ºber Nachbarn m√∂glich
    return neighborsForUpgrade(cellObj);
}

// Hilfsfunktion: Nachbarn der Zelle abrufen
function getNeighbors(cellObj) {
    return [
        grid[cellObj.y-1]?.[cellObj.x],
        grid[cellObj.y+1]?.[cellObj.x],
        grid[cellObj.y]?.[cellObj.x-1],
        grid[cellObj.y]?.[cellObj.x+1]
    ].filter(Boolean);
}

function getReachableCellsFromPaths() {
    const reachable = new Set();
    const queue = [];

    // Alle Paths als Startpunkte
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            if (cell.room === 'path') {
                const key = `${x},${y}`;
                reachable.add(key);
                queue.push(cell);
            }
        }
    }

    // Flood Fill
    while (queue.length) {
        const cell = queue.shift();
        const neighbors = getNeighbors(cell);

        neighbors.forEach(n => {
            const key = `${n.x},${n.y}`;
            if (reachable.has(key)) return;
            if (n.room === 'Clean') return;

            reachable.add(key);
            queue.push(n);
        });
    }

    return reachable;
}

function updateReachabilityVisualization() {
    const reachable = getReachableCellsFromPaths();

    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            const key = `${x},${y}`;
            cell.reachable = reachable.has(key);
        }
    }
}



	// Clean Funktion//
function canCleanCell(cellObj) {
    // Zielzelle tempor√§r entfernen
    const originalRoom = cellObj.room;
    cellObj.room = 'Clean';

    //  Alle Path-Zellen finden
    const queue = [];
    const visited = new Set();

    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            if (grid[y][x].room === 'path') {
                queue.push(grid[y][x]);
                visited.add(`${x},${y}`);
            }
        }
    }

    // 3Ô∏è‚É£ Flood Fill √ºber alle NICHT-Clean Zellen
    while (queue.length) {
        const c = queue.shift();
        const neighbors = getNeighbors(c);

        neighbors.forEach(n => {
            const key = `${n.x},${n.y}`;
            if (visited.has(key)) return;
            if (n.room === 'Clean') return;

            visited.add(key);
            queue.push(n);
        });
    }

    // 4Ô∏è‚É£ Pr√ºfen: Gibt es noch R√§ume, die nicht erreichbar sind?
    let valid = true;
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            if (cell.room !== 'Clean') {
                const key = `${x},${y}`;
                if (!visited.has(key)) {
                    valid = false;
                    break;
                }
            }
        }
    }

    // 5Ô∏è‚É£ Zustand wiederherstellen
    cellObj.room = originalRoom;
    return valid;
}




// Pr√ºft, ob der aktuell ausgew√§hlte Raum hier platziert werden darf
function neighborsForUpgrade(cellObj) {
    if (!current || current.id === 'Clean' || current.id === 'path') return true;

    const neighbors = [
        grid[cellObj.y-1]?.[cellObj.x],
        grid[cellObj.y+1]?.[cellObj.x],
        grid[cellObj.y]?.[cellObj.x-1],
        grid[cellObj.y]?.[cellObj.x+1]
    ].filter(Boolean);

    const neighborRooms = neighbors.map(n => n.room);
    const neighborTiers = neighbors.map(n => ({ room: n.room, tier: n.tier }));

    // Pr√ºfe alle Upgrade-Wege der Nachbarn
    return neighbors.some(n => {
        const upgrades = ROOM_DATA[n.room]?.upgrades || {};
        return Object.entries(upgrades).some(([tierKey, upg]) => {

            // Adjacent Upgrade pr√ºfen
            if (upg.type === 'adjacent') {
                const count = neighbors.filter(nb => upg.rooms.includes(nb.room)).length;
                if (count >= (upg.count || 1)) return true;
            }

            // Complex Upgrade pr√ºfen
            if (upg.type === 'complex') {
                const requiredOk = upg.requiredAdjacent.every(r => neighborRooms.includes(r));
                const optionalOk = upg.optionalAdjacent ? upg.optionalAdjacent.some(r => neighborRooms.includes(r)) : true;
                const minTierOk = upg.minTier ? upg.requiredAdjacent.every(r => {
                    const n = neighbors.find(nb => nb.room === r);
                    if (!n) return false;
                    return parseInt(n.tier.replace('tier','')) >= upg.minTier;
                }) : true;

                if (requiredOk && optionalOk && minTierOk) return true;
            }

            return false;
        });
    });
}

// Pr√ºft, ob auf einer bestehenden Zelle ein Upgrade m√∂glich ist
function canUpgradeToCurrent(cellObj) {
    if (!cellObj.room || cellObj.room === 'Clean') return false;
    if (cellObj.manualTier) return false; // manuell gesetzte Tiers nicht automatisch upgraden

    const nextTierKey = nextTier(cellObj.tier);
    if (!nextTierKey) return false;

    const roomUpgrades = ROOM_DATA[cellObj.room]?.upgrades || {};
    const upgradeInfo = roomUpgrades[nextTierKey];
    if (!upgradeInfo) return false;

    const neighbors = [
        grid[cellObj.y-1]?.[cellObj.x],
        grid[cellObj.y+1]?.[cellObj.x],
        grid[cellObj.y]?.[cellObj.x-1],
        grid[cellObj.y]?.[cellObj.x+1]
    ].filter(Boolean);

    const neighborRooms = neighbors.map(n => n.room);

    // Adjacent Upgrade
    if (upgradeInfo.type === 'adjacent') {
        const count = neighbors.filter(n => upgradeInfo.rooms.includes(n.room)).length;
        return count >= (upgradeInfo.count || 1);
    }

    // Complex Upgrade
    if (upgradeInfo.type === 'complex') {
        const requiredOk = upgradeInfo.requiredAdjacent.every(r => neighborRooms.includes(r));
        const optionalOk = upgradeInfo.optionalAdjacent ? upgradeInfo.optionalAdjacent.some(r => neighborRooms.includes(r)) : true;
        const minTierOk = upgradeInfo.minTier ? upgradeInfo.requiredAdjacent.every(r => {
            const n = neighbors.find(nb => nb.room === r);
            if (!n) return false;
            return parseInt(n.tier.replace('tier','')) >= upgradeInfo.minTier;
        }) : true;

        return requiredOk && optionalOk && minTierOk;
    }

    return false;
}




function updateTier(x, y) {
    const cellObj = grid[y][x];
    if (!cellObj.room || cellObj.room === 'Clean') return;

    // Manuell gesetztes Tier immer priorisieren
    if (cellObj.manualTier) {
        renderCell(cellObj);
        return;
    }

    const room = ROOM_DATA[cellObj.room];
    const neighbors = [
        [x-1, y], [x+1, y], [x, y-1], [x, y+1]
    ];

    // Spezialf√§lle zuerst
    switch (cellObj.room) {
        case 'spymasters_study':
            {
                let tier = 'tier1';
                const removedNeighbors = neighbors.reduce((count,[nx,ny])=>{
                    const n = grid[ny]?.[nx];
                    if(!n) return count;
                    if(n.room === 'Clean') return count+1;
                    return count;
                },0);
                if (removedNeighbors >= 2) tier = 'tier3';
                else if (removedNeighbors >= 1) tier = 'tier2';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'altar_of_sacrifice':
            {
                let tier = 'tier1';
                const removedNeighbors = neighbors.reduce((count,[nx,ny])=>{
                    const n = grid[ny]?.[nx];
                    if(!n) return count;
                    if(n.room === 'Clean') return count+1;
                    return count;
                },0);
                if (removedNeighbors >= 2) tier = 'tier3';
                else if (removedNeighbors >= 1) tier = 'tier2';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'thaumaturges_laboratory':
            {
                let tier = 'tier1';
                const sacrificialNeighbors = neighbors
                    .map(([nx, ny]) => grid[ny]?.[nx])
                    .filter(n => n && n.room === 'altar_of_sacrifice');
                const hasTier3Altar = sacrificialNeighbors.some(n => n.tier === 'tier3');
                const altarCount = sacrificialNeighbors.length;
                if (hasTier3Altar || altarCount >= 2) tier = 'tier3';
                else if (altarCount >= 1) tier = 'tier2';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'commanders_chamber':
            {
                let tier = 'tier1';
                let guardhouseCount = 0;
                neighbors.forEach(([nx, ny]) => {
                    const n = grid[ny]?.[nx];
                    if (n && n.room === 'guardhouse') guardhouseCount++;
                });
                if (guardhouseCount >= 3) tier = 'tier3';
                else if (guardhouseCount >= 2) tier = 'tier2';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'bronzeworks':
            {
                let tier = 'tier1';
                const hasWorkshop = neighbors.some(([nx, ny]) => {
                    const n = grid[ny]?.[nx];
                    return n && n.room === 'workshop';
                });
                const genNearby = countPoweringGenerators(x, y) > 0;
                if (hasWorkshop || genNearby) tier = 'tier2';
                if (hasWorkshop && genNearby) tier = 'tier3';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'synthflesh_lab':
            {
                let tier = 'tier1';
                const surgeonNeighbors = neighbors
                    .map(([nx,ny]) => grid[ny]?.[nx])
                    .filter(n => n && n.room === 'surgeons_ward');
                const hasSurgeon = surgeonNeighbors.length > 0;
                const genNearby = countPoweringGenerators(x, y) > 0;
                if (hasSurgeon || genNearby) tier = 'tier2';
                if (hasSurgeon && surgeonNeighbors.some(n => n.tier === 'tier2' || n.tier === 'tier3') && genNearby) tier = 'tier3';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'surgeons_ward':
            {
                let tier = 'tier1';
                const synthLabs = neighbors
                    .map(([nx, ny]) => grid[ny]?.[nx])
                    .filter(n => n && n.room === 'synthflesh_lab');
                if (synthLabs.length >= 1) tier = 'tier2';
                if (synthLabs.length >= 2 || synthLabs.some(n => n.tier === 'tier3')) tier = 'tier3';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'workshop':
            {
                let tier = 'tier1';
                const genCount = countPoweringGenerators(x, y);
                if (genCount >= 2) tier = 'tier3';
                else if (genCount >= 1) tier = 'tier2';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
			
    }

    // Generische Upgrade-Logik f√ºr R√§ume mit ROOM_DATA.upgrades
    const roomUpgrades = room.upgrades || {};
    let maxTierAchieved = 'tier1';

    for (const tierKey in roomUpgrades) {
        const upgrade = roomUpgrades[tierKey];
        if (upgrade.type === 'adjacent') {
            let count = 0;
            neighbors.forEach(([nx, ny]) => {
                const n = grid[ny]?.[nx];
                if (!n) return;
                if (upgrade.rooms.includes(n.room)) count++;
            });
            if (count >= upgrade.count) maxTierAchieved = maxTier(maxTierAchieved, tierKey);
        } else 
		if (upgrade.type === 'complex') {
    const hasAll = upgrade.requiredAdjacent.every(reqRoom =>
        neighbors.some(n => n.room === reqRoom)
    );

    if (hasAll) {
        tier = Number(tierKey);
    }
}

    }

    cellObj.tier = maxTierAchieved;
    renderCell(cellObj);
}
				// UPdatetier fertig //

function recalcAllTiers() {
    // 1Ô∏è‚É£ Schritt: Alle R√§ume auf Tier1 zur√ºcksetzen (au√üer manualTier)
    for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[y].length; x++) {
            const cell = grid[y][x];
            if (cell.room && !cell.manualTier) {
                cell.tier = 'tier1';
            }
        }
    }

    // 2Ô∏è‚É£ Schritt: Iteratives Update, um Abh√§ngigkeiten zu ber√ºcksichtigen
    let changed;
    let iteration = 0;
    const maxIterations = 10; // Sicherheit, um Endlosschleifen zu vermeiden
    do {
        changed = false;
        iteration++;

        for (let y = 0; y < grid.length; y++) {
            for (let x = 0; x < grid[y].length; x++) {
                const cell = grid[y][x];
                if (!cell.room || cell.room === 'Clean') continue;

                const oldTier = cell.tier;

                // üîπ generisches Update f√ºr Tier1‚Äì3
                updateTier(x, y);

                if (cell.tier !== oldTier) changed = true;
            }
        }

        // üîπ Spezielles Update f√ºr Garrison (Tier4‚Äì7)
        for (let y = 0; y < grid.length; y++) {
            for (let x = 0; x < grid[y].length; x++) {
                const cell = grid[y][x];
                if (cell.room === 'guardhouse' && !cell.manualTier) {
                    const oldTier = cell.tier;
                    updateGuardhouseVariant(x, y);
                    if (cell.tier !== oldTier) changed = true;
                }
            }
        }

    } while (changed && iteration < maxIterations);

      // 3Ô∏è‚É£ Durchg√§nge neu berechnen
    updateReachability();
	updateBridges();


    // 4Ô∏è‚É£ Alle Zellen rendern
    for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[y].length; x++) {
            renderCell(grid[y][x]);
        }
    }
}


function updateReachability() {
    // 1Ô∏è‚É£ Alle Zellen erstmal als nicht erreichbar markieren
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            grid[y][x].reachable = false;
        }
    }

    // 2Ô∏è‚É£ Startpunkte: alle Paths
    const queue = [];

    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            if (cell.room === 'path') {
                cell.reachable = true;
                queue.push(cell);
            }
        }
    }

    // 3Ô∏è‚É£ Flood-Fill √ºber erlaubte Verbindungen
    while (queue.length > 0) {
        const cell = queue.shift();

        const neighbors = getNeighbors(cell);
        neighbors.forEach(n => {
            if (n.reachable) return;
            if (n.room === 'Clean') return;

            // Verbindung pr√ºfen
            if (areRoomsConnected(cell, n)) {
                n.reachable = true;
                queue.push(n);
            }
        });
    }
}

function updateBridges() {
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            if (!cell.bridges) continue;

            // Reset
            Object.values(cell.bridges).forEach(b => {
			b.classList.remove("active");
			});


            if (!cell.reachable) continue;

            const neighbors = getNeighbors(cell);

            neighbors.forEach(n => {
                if (!n.reachable) return;
                if (!areRoomsConnected(cell, n)) return;

                if (n.x === cell.x && n.y === cell.y - 1) {
                    cell.bridges.up.classList.add("up", "active");
                }
                if (n.x === cell.x && n.y === cell.y + 1) {
                    cell.bridges.down.classList.add("down", "active");
                }
                if (n.x === cell.x - 1 && n.y === cell.y) {
                    cell.bridges.left.classList.add("left", "active");
                }
                if (n.x === cell.x + 1 && n.y === cell.y) {
                    cell.bridges.right.classList.add("right", "active");
                }
            });
        }
    }
}


function areRoomsConnected(a, b) {

    // 1Ô∏è‚É£ Path verbindet immer
    if (a.room === 'path' || b.room === 'path') return true;

    // 2Ô∏è‚É£ Dynamo-Sonderlogik
    if (a.room === 'dynamo' || b.room === 'dynamo') {
        const dyn = a.room === 'dynamo' ? a : b;
        const other = dyn === a ? b : a;

        // Dynamo ‚Üî Path
        if (other.room === 'path') return true;

        // Dynamo ‚Üí Geb√§ude, die es upgraden kann
        const dynUpgrades = ROOM_DATA['dynamo']?.upgrades || {};
        for (const upg of Object.values(dynUpgrades)) {
            if (upg.rooms?.includes(other.room)) return true;
        }

        // Geb√§ude ‚Üí Dynamo (Geb√§ude braucht Dynamo)
        const otherUpgrades = ROOM_DATA[other.room]?.upgrades || {};
        for (const upg of Object.values(otherUpgrades)) {
            if (upg.rooms?.includes('dynamo')) return true;
            if (upg.requiredAdjacent?.includes('dynamo')) return true;
        }

        return false;
    }

    // 3Ô∏è‚É£ Normale Upgrade-basierte Verbindung
    const aUpgrades = ROOM_DATA[a.room]?.upgrades || {};
    const bUpgrades = ROOM_DATA[b.room]?.upgrades || {};

    for (const upg of Object.values(aUpgrades)) {
        if (upg.type === 'adjacent' && upg.rooms?.includes(b.room)) return true;
        if (upg.type === 'complex' && upg.requiredAdjacent?.includes(b.room)) return true;
    }

    for (const upg of Object.values(bUpgrades)) {
        if (upg.type === 'adjacent' && upg.rooms?.includes(a.room)) return true;
        if (upg.type === 'complex' && upg.requiredAdjacent?.includes(a.room)) return true;
    }

    return false;
}




// Hilfsfunktion: h√∂heres Tier
function maxTier(t1, t2) {
    const n1 = parseInt(t1.replace('tier',''));
    const n2 = parseInt(t2.replace('tier',''));
    return n1 >= n2 ? t1 : t2;
}

// renderCell anpassen f√ºr Sidebar/Tooltip
function renderCell(cellObj) {
    if (!ROOM_DATA[cellObj.room]) return;

    const room = ROOM_DATA[cellObj.room];
    const content = cellObj.el.querySelector(".cell-content");
    if (!content) return;

    // ----------------------------
    // Zellenfarbe
    cellObj.el.style.backgroundColor = room.color;

    // ----------------------------
    // Grid-Rotation
    const gridRotation = window.gridRotation || 0;
    cellObj.el.style.transform = `rotate(${gridRotation}deg)`;

    // Content richtet Rotation wieder aus
    content.style.position = "relative";
    content.style.width = "100%";
    content.style.height = "100%";
    content.style.transform = `rotate(${-gridRotation}deg)`;

    // ----------------------------
    // ICON ELEMENT
    let iconEl = content.querySelector(".cell-icon");
    if (!iconEl) {
        iconEl = document.createElement("div");
        iconEl.classList.add("cell-icon");
        content.appendChild(iconEl);
    }

    // Icon Styling
    iconEl.style.position = "absolute";
    iconEl.style.top = "50%";
    iconEl.style.left = "50%";
    iconEl.style.width = "70%";
    iconEl.style.height = "70%";
	iconEl.style.transform = "translate(-50%, -50%) rotate(-45deg)";
    iconEl.style.backgroundRepeat = "no-repeat";
    iconEl.style.backgroundSize = "contain";
    iconEl.style.backgroundPosition = "center";
    iconEl.style.pointerEvents = "none";

    // Icon setzen
if (cellObj.room === "guardhouse") {
    if (["tier4","tier5"].includes(cellObj.tier) && room.transcendentIcon) {
        // Transcendent Barracks Icon
        iconEl.style.backgroundImage = `url(${room.transcendentIcon})`;
        iconEl.style.display = "block";
    } else if (["tier6","tier7"].includes(cellObj.tier) && room.legionIcon) {
        // Legion Barracks Icon
        iconEl.style.backgroundImage = `url(${room.legionIcon})`;
        iconEl.style.display = "block";
    } else {
        // Standard Guardhouse Icon
        iconEl.style.backgroundImage = room.icon ? `url(${room.icon})` : "";
        iconEl.style.display = room.icon ? "block" : "none";
    }
} else {
    // Alle anderen R√§ume
    iconEl.style.backgroundImage = (cellObj.room !== "Clean" && room.icon) ? `url(${room.icon})` : "";
    iconEl.style.display = (cellObj.room !== "Clean" && room.icon) ? "block" : "none";
}


    // ----------------------------
    // LABEL-CONTAINER (nur Tier)
    let labelEl = content.querySelector(".cell-label");
    if (!labelEl) {
        labelEl = document.createElement("div");
        labelEl.classList.add("cell-label");
        content.appendChild(labelEl);
    }

    labelEl.style.position = "absolute";
    labelEl.style.inset = "0";
    labelEl.style.pointerEvents = "none";

    // ----------------------------
    // TIER
    let tierEl = labelEl.querySelector(".cell-tier");
    if (!tierEl) {
        tierEl = document.createElement("span");
        tierEl.classList.add("cell-tier");
        labelEl.appendChild(tierEl);
    }

    if (
        cellObj.room === "guardhouse" &&
        ["tier4", "tier5", "tier6", "tier7"].includes(cellObj.tier)
    ) {
        const tierMapping = { tier4: 2, tier5: 3, tier6: 2, tier7: 3 };
        tierEl.textContent = tierMapping[cellObj.tier] || "";
    } else {
       // Keine Tieranzeige f√ºr Path
if (cellObj.room === "path" || cellObj.room === "Clean") {
    tierEl.textContent = "";
} 
// Sonderfall Guardhouse (Legion / Transcendent)
else if (
    cellObj.room === "guardhouse" &&
    ["tier4", "tier5", "tier6", "tier7"].includes(cellObj.tier)
) {
    const tierMapping = { tier4: 2, tier5: 3, tier6: 2, tier7: 3 };
    tierEl.textContent = tierMapping[cellObj.tier] || "";
} 
// Alle anderen R√§ume
else {
    tierEl.textContent = cellObj.tier.replace("tier", "");
}

    }

    tierEl.style.position = "absolute";
    tierEl.style.right = "4px";
    tierEl.style.bottom = "2px";
    tierEl.style.fontSize = "18px";
    tierEl.style.fontWeight = "bold";
    tierEl.style.color = "#fff";
    tierEl.style.textShadow = "0 0 3px #000";

    // ----------------------------
    // Energie & Reachability
    if (!hasRequiredEnergy(cellObj)) {
        cellObj.el.classList.add("no-power");
    } else {
        cellObj.el.classList.remove("no-power");
    }
}



// Hilfsfunktion: Rotation der Initialen/Tier-Nummer gegen die Grid-Drehung
function getCellRotation(cellObj) {
    // Beispiel: wenn das Grid insgesamt z.B. 90¬∞ gedreht ist, k√∂nnen wir gegenrotieren
    // Hier anpassen, je nachdem wie du die Grid-Drehung speicherst
    const gridRotation = window.gridRotation || 0; // global variable oder berechnet
    return -0;
}




function updateGuardhouseVariant(x, y) {
    const cellObj = grid[y][x];
    if (!cellObj.room || cellObj.room !== 'guardhouse') return;

    const neighbors = [
        [x-1, y], [x+1, y], [x, y-1], [x, y+1]
    ];

    // Liste der angrenzenden Raum-IDs
    const adjacentRooms = neighbors
        .map(([nx, ny]) => grid[ny]?.[nx]?.room)
        .filter(r => r);

    let newTier = 'tier1';
    const room = ROOM_DATA['guardhouse'];

    // -----------------------------
    // Upgrade-Logik f√ºr alle definierten Upgrades
    for (const tier in room.upgrades) {
        const upgrade = room.upgrades[tier];

        if (upgrade.type === 'adjacent') {
            if (upgrade.requireAll) {
                // Tier nur, wenn alle R√§ume vorhanden sind
                const allPresent = upgrade.rooms.every(r => adjacentRooms.includes(r));
                if (allPresent) newTier = tier;
            } else {
                // alte Logik: mindestens upgrade.count R√§ume vorhanden
                let count = 0;
                upgrade.rooms.forEach(r => {
                    if (adjacentRooms.includes(r)) count++;
                });
                if (count >= (upgrade.count || 1)) newTier = tier;
            }
        }

        // -----------------------------
        // Komplexe Upgrades pr√ºfen (Tier4, Tier6)
        if (upgrade.type === 'complex') {
            const hasRequired = upgrade.requiredAdjacent.every(r => adjacentRooms.includes(r));
            const hasOptional = upgrade.optionalAdjacent ? upgrade.optionalAdjacent.some(r => adjacentRooms.includes(r)) : true;
            if (hasRequired && hasOptional) newTier = tier;
        }
    }

    cellObj.tier = newTier;
    renderCell(cellObj);
}


function countConnectedGenerators(x, y) {
  const visited = new Set();
  const stack = [[x, y]];
  let generators = 0;

  while (stack.length) {
    const [cx, cy] = stack.pop();
    const key = `${cx},${cy}`;
    if (visited.has(key)) continue;
    visited.add(key);

    const cell = grid[cy]?.[cx];
    if (!cell) continue;

    if (GENERATOR_ROOMS.includes(cell.room)) {
      generators++;
      continue;
    }

  // Energie kann durch alle R√§ume flie√üen (au√üer au√üerhalb des Grids)


    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy]) => {
      stack.push([cx+dx, cy+dy]);
    });
  }

  return generators;
}

function distance(a, b) {
  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

function getActiveGenerators() {
  const generators = [];

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      if (cell.room === "dynamo") {
        generators.push(cell);
      }
    }
  }

  return generators;
}

function getGeneratorBonusForCell(targetCell) {
  const generators = getActiveGenerators();
  let bonus = 0;

  generators.forEach(gen => {
    const maxRange = getGeneratorRange(gen.tier);

    const visited = new Set();
    const queue = [{ x: gen.x, y: gen.y, distance: 0 }];
    let reachesTarget = false;

    while (queue.length && !reachesTarget) {
      const { x, y, distance } = queue.shift();
      const key = `${x},${y}`;
      if (visited.has(key)) continue;
      visited.add(key);

      if (x === targetCell.x && y === targetCell.y) {
        reachesTarget = true;
        break;
      }

      if (distance >= maxRange) continue;

      const neighbors = [
        [x+1,y], [x-1,y], [x,y+1], [x,y-1]
      ];

      neighbors.forEach(([nx, ny]) => {
        const cell = grid[ny]?.[nx];
        if (!cell) return;
        // Energie flie√üt durch alle R√§ume, au√üer leere Tiles blockieren evtl.
        if (cell.room !== 'Clean') {
          queue.push({ x: nx, y: ny, distance: distance+1 });
        }
      });
    }

    if (reachesTarget) {
      const room = ROOM_DATA["dynamo"];
      const tierEffects = room.variants[gen.tier]?.effects || [];
      tierEffects.forEach(effect => {
        const match = effect.match(/(\d+)%/);
        if (match) bonus += parseInt(match[1]);
      });
    }
  });

  return bonus;
}
		//UpdateEffectsSidebar//
function updateEffectsSidebar() {
  sidebarContent.innerHTML = "";

  // 1Ô∏è‚É£ R√§ume nach roomId + tier gruppieren
  const grouped = {};

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      if (!cell.room || cell.room === 'Clean') continue;

      const room = ROOM_DATA[cell.room];
      const tier = cell.tier;
      const hasPower = hasRequiredEnergy(cell);

      const key = `${cell.room}-${tier}`;

      if (!grouped[key]) {
        grouped[key] = {
          room: room,
          tier: tier,
          cells: [],
          hasPower: hasPower
        };
      }
      grouped[key].cells.push(cell);
      if (!hasPower) grouped[key].hasPower = false;
    }
  }

  // 2Ô∏è‚É£ Jede Gruppe in der Sidebar darstellen
  for (const key in grouped) {
    const group = grouped[key];
    const room = group.room;
    const tierData = room.variants[group.tier];
    if (!tierData) continue;

    const count = group.cells.length;
    const hasPower = group.hasPower;

    const roomBlock = document.createElement("div");
    roomBlock.style.marginBottom = "12px";

    // √úberschrift mit Anzahl und Gesamt-Effekt
    const title = document.createElement("strong");
    const displayTier = TIER_DISPLAY_NAME[group.tier] || group.tier;

    let totalEffectText = "";
    if (tierData.effects.length > 0) {
      const percentMatch = tierData.effects[0].match(/(\d+)%/);
      if (percentMatch) {
        const perRoom = parseInt(percentMatch[1]);
        const total = perRoom * count;
        totalEffectText = `${total}% ${tierData.effects[0].replace(/^\d+% /, '')}`;
      }
    }

    title.innerText = `${room.name} (${displayTier}) x${count} = ${totalEffectText}`;
    title.style.color = hasPower ? "#fff" : "#ff5555";
    roomBlock.appendChild(title);

    // Einzelne Effekte auflisten
    const ul = document.createElement("ul");
    ul.style.margin = "4px 0 0 12px";

    for (let i = 0; i < count; i++) {
      tierData.effects.forEach(effect => {
        const li = document.createElement("li");
        li.innerText = effect;

        // ‚úÖ Farbe der Effekte: gr√ºn, wenn aktiv, rot, wenn keine Energie
        li.style.color = hasPower ? "#00ff00" : "#ff5555";

        ul.appendChild(li);
      });
    }

    roomBlock.appendChild(ul);

    // Warnung, wenn keine Energie
    if (!hasPower) {
      const warning = document.createElement("div");
      warning.innerText = "‚ö† Needs Dynamo in range to work";
      warning.style.color = "#ff5555";
      warning.style.fontSize = "11px";
      warning.style.marginTop = "4px";
      warning.style.fontStyle = "italic";
      roomBlock.appendChild(warning);
    }

    sidebarContent.appendChild(roomBlock);
  }

  if (sidebarContent.innerHTML === "") {
    sidebarContent.innerHTML = "<em>No room effects yet.</em>";
  }
}
//reset button
const resetButton = document.getElementById('reset-button').onclick = () => {
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            cell.room = 'Clean';
            cell.tier = 'tier1';
            cell.manualTier = false;
            renderCell(cell);
        }
    }
    // Stra√üe wieder setzen
    const startCell = grid[gridSize - 1][4];
    startCell.room = 'path';
    startCell.tier = 'tier1';
    renderCell(startCell);

    recalcAllTiers();
    updateGeneratorRanges();
    updateEffectsSidebar();



  // Optional: aktive Palette abw√§hlen
  document.querySelectorAll('.room-palette-item').forEach(item => {
    item.classList.remove('active');
  });
};

const saveButton = document.getElementById("save-button");
const loadButton = document.getElementById("load-button");
const exportButton = document.getElementById("export-button");

saveButton.onclick = saveLayout;
exportButton.onclick = exportLayoutAsLink;

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cellObj = grid[y][x];
      cellObj.room = 'Clean';
      cellObj.tier = 'tier1';
	  cellObj.manualTier = false;

      renderCell(cellObj);
    }
  }
  updateEffectsSidebar();

// countPoweringGenerators nur noch mit isUpgradedByGenerator
function countPoweringGenerators(x, y) {
    let count = 0;
    const generators = getActiveGenerators();

    generators.forEach(gen => {
        const maxRange = getGeneratorRange(gen.tier);
        const visited = new Set();
        const queue = [{ x: gen.x, y: gen.y, distance: 0 }];

        while (queue.length) {
            const { x: cx, y: cy, distance } = queue.shift();
            const key = `${cx},${cy}`;
            if (visited.has(key)) continue;
            visited.add(key);

            if (distance > maxRange) continue;

            const cell = grid[cy]?.[cx];
            if (!cell) continue;

            // Ziel erreicht
            if (cx === x && cy === y) {
                count++;
                break;
            }

            // Energie flie√üt durch alle R√§ume au√üer Clean
            if (cell.room === 'Clean') continue;

            // Nachbarn pr√ºfen
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx, dy]) => {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                    queue.push({ x: nx, y: ny, distance: distance + 1 });
                }
            });
        }
    });

    return count;
}


// Angepasste isUpgradedByGenerator f√ºr deine R√§ume
function isUpgradedByGenerator(cellObj) {
    const upgradeable = ['bronzeworks','synthflesh_lab','workshop'];
    if (!upgradeable.includes(cellObj.room)) return false;
    return isPoweredByGenerator(cellObj);
}

// Pr√ºft, ob ein Raum von mindestens einem Generator tats√§chlich erreicht wird
function isPoweredByGenerator(cellObj) {
    const generators = getActiveGenerators();
    if (!generators.length) return false;

    for (const gen of generators) {
        const maxRange = getGeneratorRange(gen.tier);
        const visited = new Set();
        const queue = [{ x: gen.x, y: gen.y, distance: 0 }];

        while (queue.length) {
            const { x, y, distance } = queue.shift();
            const key = `${x},${y}`;
            if (visited.has(key)) continue;
            visited.add(key);

            if (x === cellObj.x && y === cellObj.y) return true;
            if (distance >= maxRange) continue;

            // Energie darf nur durch R√§ume flie√üen, au√üer leere Tiles blockieren
            const cell = grid[y]?.[x];
            if (!cell) continue;

            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx, dy]) => {
                const nx = x + dx;
                const ny = y + dy;
                const nCell = grid[ny]?.[nx];
                if (nCell && nCell.room !== 'Clean') {
                    queue.push({ x: nx, y: ny, distance: distance + 1 });
                }
            });
        }
    }

    return false;
}
 
// Pr√ºft, ob die Zelle gen√ºgend Generator-Energie hat
function hasRequiredEnergy(cellObj) {
    const roomId = cellObj.room;

    // Nur bestimmte R√§ume ben√∂tigen Generator
    const roomsNeedingGenerator = ['workshop', 'bronzeworks', 'synthflesh_lab'];
    if (!roomsNeedingGenerator.includes(roomId)) return true;

    const genCount = countPoweringGenerators(cellObj.x, cellObj.y);
    const neighbors = [
        [cellObj.x-1, cellObj.y], [cellObj.x+1, cellObj.y],
        [cellObj.x, cellObj.y-1], [cellObj.x, cellObj.y+1]
    ];

    if (roomId === 'workshop') {
        if (cellObj.tier === 'tier3') return genCount >= 2;
        if (cellObj.tier === 'tier2') return genCount >= 1;
        return true;
    }

    if (roomId === 'bronzeworks') {
        const hasWorkshopAdjacent = neighbors.some(([nx, ny]) => {
            const n = grid[ny]?.[nx];
            return n && n.room === 'workshop';
        });
        if (cellObj.tier === 'tier3') return hasWorkshopAdjacent && genCount > 0;
        if (cellObj.tier === 'tier2') return hasWorkshopAdjacent || genCount > 0;
        return true;
    }

    if (roomId === 'synthflesh_lab') {
        const hasSurgeonAdjacent = neighbors.some(([nx, ny]) => {
            const n = grid[ny]?.[nx];
            return n && n.room === 'surgeons_ward';
        });
        if (cellObj.tier === 'tier3') return hasSurgeonAdjacent && genCount > 0;
        if (cellObj.tier === 'tier2') return hasSurgeonAdjacent || genCount > 0;
        return true;
    }

    return true;
}

function updateGeneratorRanges() {
  // alles zur√ºcksetzen
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      grid[y][x].el.classList.remove("generator-edge");
      grid[y][x].inGeneratorRange = false;
    }
  }

  if (!current || current.id !== "dynamo") return;

  const generators = getActiveGenerators();

  generators.forEach(gen => {
    const genRoom = ROOM_DATA[gen.room];
	const range = genRoom.energyRangeByTier[gen.tier] || 0;

    // 1Ô∏è‚É£ Reichweite markieren
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (distance(gen, grid[y][x]) <= range) {
          grid[y][x].inGeneratorRange = true;
        }
      }
    }
  });
  // 2Ô∏è‚É£ Nur √§u√üere Kante markieren
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      if (!cell.inGeneratorRange) continue;

      const neighbors = [
        [x-1,y], [x+1,y], [x,y-1], [x,y+1]
      ];

      const isEdge = neighbors.some(([nx, ny]) =>
        !grid[ny]?.[nx]?.inGeneratorRange
      );

      if (isEdge) {
        cell.el.classList.add("generator-edge");
      }
    }
  }
}

// ------------------------------
// üîπ Grid initialisieren (leer + Path)
function initEmptyGrid() {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      cell.room = 'Clean';
      cell.tier = 'tier1';
      cell.manualTier = false;
      renderCell(cell);
    }
  }

  // Path auf unterste Reihe, Spalte 5
  const pathY = gridSize - 1;
  const pathX = 4;
  const pathCell = grid[pathY][pathX];
  pathCell.room = 'path';
  pathCell.tier = 'tier1';
  renderCell(pathCell);

  // Berechne Effekte & Tier-Anpassungen
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      updateTier(x, y);
      updateGuardhouseVariant(x, y);
    }
  }
  recalcAllTiers();
  updateEffectsSidebar();
}

// ------------------------------
// üíæ Layout speichern (Save-Button)
function saveLayout() {
  const layout = [];
  for (let y = 0; y < gridSize; y++) {
    layout[y] = [];
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      layout[y][x] = { room: cell.room, tier: cell.tier };
    }
  }
  localStorage.setItem("atziriTempleLayout", JSON.stringify(layout));
  alert("Layout saved!");
}

// ------------------------------
// Layout aus URL importieren
function importLayoutFromCode(code) {
  try {
    const decoded = atob(code);
    let index = 0;

    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const roomCode = decoded[index] || "_";
        const tierCode = decoded[index + 1] || "1";
        index += 2;

        const cell = grid[y][x];
        cell.room = ROOM_CODE_MAP_REVERSE[roomCode] || "Clean";
        cell.tier = codeToTier(tierCode);
        cell.manualTier = (cell.room === 'spymasters_study' || cell.room === 'altar_of_sacrifice');

        renderCell(cell);
      }
    }

    // Alles neu berechnen
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        updateTier(x, y);
        updateGuardhouseVariant(x, y);
      }
    }
    recalcAllTiers();
    updateEffectsSidebar();

  } catch (e) {
    console.error("Failed to import layout:", e);
    initEmptyGrid(); // Fallback
  }
}

// ------------------------------
// üì§ Layout exportieren
function exportLayoutAsLink() {
  saveLayout(); // speichert den aktuellen Stand

  let raw = "";
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      const roomCode = ROOM_CODE_MAP[cell.room] || "_";
      const tierCode = tierToCode(cell.tier || "tier1");
      raw += roomCode + tierCode;
    }
  }

  const encoded = btoa(raw);
  const url = `${location.origin}${location.pathname}#L=${encoded}`;

  navigator.clipboard.writeText(url).then(() => {
    alert("URL copied to clipboard!");
  }).catch(err => {
    console.error("Clipboard couldn't be written:", err);
    alert("Clipboard couldn't be written: " + url);
  });
}

function tierToCode(tier) { return tier.replace("tier", ""); }
function codeToTier(code) { return "tier" + code; }

// ------------------------------
// Reset Button
document.getElementById('reset-button').onclick = () => {
  initEmptyGrid();
  document.querySelectorAll('.room-palette-item').forEach(item => item.classList.remove('active'));
};

// ------------------------------
// Save & Export Buttons
document.getElementById("save-button").onclick = saveLayout;
document.getElementById("export-button").onclick = exportLayoutAsLink;

// ------------------------------
// üîπ Page Load
window.addEventListener("load", () => {
  const hash = location.hash;

  if (hash.startsWith("#L=")) {
    const code = hash.slice(3);
    importLayoutFromCode(code); // URL-Layout wird geladen
  } else {
    initEmptyGrid(); // Standard: leeres Grid + Path
  }
});


// ------------------------------
// üîπ Load Button (aus LocalStorage)
document.getElementById("load-button").onclick = () => {
  const raw = localStorage.getItem("atziriTempleLayout");
  if (!raw) {
    alert("No saved layout found!");
    return;
  }

  const layout = JSON.parse(raw);

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const saved = layout[y][x];
      const cell = grid[y][x];

      if (saved && saved.room) {
        cell.room = saved.room;
        cell.tier = saved.tier || 'tier1';
        cell.manualTier = (cell.room === 'spymasters_study' || cell.room === 'altar_of_sacrifice');
      } else {
        cell.room = 'Clean';
        cell.tier = 'tier1';
        cell.manualTier = false;
      }

      renderCell(cell);
    }
  }

  // Alles neu berechnen
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      updateTier(x, y);
      updateGuardhouseVariant(x, y);
    }
  }

  recalcAllTiers();
  updateEffectsSidebar();
  
};




// -------------------- Info Box Toggle --------------------
const toggleInfoBtn = document.getElementById("toggle-info-btn");
const infoBox = document.getElementById("info-box");

toggleInfoBtn.addEventListener("click", () => {
  infoBox.classList.toggle("expanded");
});


</script>

</body>
</html>
