<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Atziris Temple Planner</title>
<style>
  body {
    font-family: sans-serif;
    background: #222;
    color: #eee;
    display: flex;
	flex-direction: column;
    align-items: center; /* Sidebar oben */
    padding-top: 40px;
    min-height: 100vh;
    margin: 0;
  }
  
#editor-title {
  text-align: center;
  color: #fff;
  font-size: 28px;
  font-weight: bold;
  margin-bottom: 20px;
  margin-top: 30px;
  font-family: 'Arial', sans-serif;
}
 
#editor-container {
  display: flex;
  gap: 20px;
  justify-content: center;
  align-items: flex-start;
  margin-top: 20px;
}

/* Grid */
#grid-container { display: flex; justify-content: center; }

#grid {
  display: grid;
  grid-template-columns: repeat(9, 60px);
  grid-template-rows: repeat(9, 60px);
  transform: rotate(45deg);
  margin-top: 120px;
  margin-right: 120px;
}

/* Grid-Zellen */
.cell {
  width: 60px;
  height: 60px;
  background:#222;
  border: 1px solid #333;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  overflow: hidden;
  position: relative;
}

.cell span {
  transform: rotate(-45deg); /* Inhalt gegen Grid-Rotation drehen */
  display: block;
}

.cell span.room-initial {
  display: block;
  top: 10px;
  transform: rotate(-45deg);
  font-size: 18px;
  font-weight: bold;
  color: #000;
  
}

.cell span.tier-number {
  bottom: 5px;
  right: 3px;
  transform: translateX(-50%, -50%) rotate(-45deg); /* gegen Grid-Rotation */
  font-size: 18px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 0 2px #000;
}


/* Hover-Effekt f√ºr Grid-Zellen */
.cell:hover {
  transform: scale(1.05);        /* leichtes Vergr√∂√üern */
  border-color: #fff;            /* wei√üe Umrandung */
  box-shadow: 0 0 10px rgba(255,255,255,0.5); /* leichter Glow */
  transition: transform 0.1s, border-color 0.1s, box-shadow 0.1s;
}


.cell span { transform: rotate(-45deg); }

/* Sidebar */
#sidebar {
  width: 420px;
  padding: 20px;
  background: #181818;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* Aktueller Raum */
#current-room-display {
  text-align: center;
  font-weight: bold;
  font-size: 16px;
}

/* Palette */
#palette-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
}


/* Palette Buttons */
.room-palette-item {
  width: 100px;
  height: 60px;
  border: 1px solid #555;
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  line-height: 1.1;
  color: black;
  padding: 2px;
  overflow-wrap: break-word;
  word-break: break-word;
  transition: transform 0.15s, border-color 0.15s, box-shadow 0.15s;
}

.room-palette-item:hover {
  border: 2px solid #00ff00; 
  box-shadow: 0 0 12px #00ff00; /* sanfter Glow */
  transform: scale(1.08);       /* leicht gr√∂√üer */
}


/* Effekte-Anzeige */
#effects-display {
  border: 1px solid #888;
  padding: 10px;
  min-height: 200px;
  background-color: #222;
  color: #fff;
  font-size: 12px;
  overflow-y: auto;
}

#big-a {
  position: absolute;
  font-size: 60px;
  font-weight: bold;
  color: red;
  pointer-events: none;
  transform: translate(-50%, -50%); /* Zentrum des A */
}

.no-power {
  filter: grayscale(100%);
  opacity: 0.5;
}

.generator-edge {
  position: relative;
  z-index: 1;
}

.generator-edge::before {
  content: "";
  position: absolute;
  inset: -2px;
  border-radius: 4px;
  background: linear-gradient(
    90deg,
    transparent 0%,
    rgba(143, 202, 242, 0.0) 20%,
    rgba(143, 202, 242, 1.2) 50%,
    rgba(143, 202, 242, 0.0) 80%,
    transparent 100%
  );
  background-size: 300% 300%;
  animation: energyRun 2.2s linear infinite;
  pointer-events: none;
  mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  mask-composite: exclude;
  -webkit-mask-composite: xor;
  padding: 3px;
}

@keyframes energyRun {
  from { background-position: 0% 50%; }
  to   { background-position: 300% 50%; }
}

/* Palette links, Buttons rechts */
#palette-and-buttons {
  display: flex;
  align-items: flex-start;
  gap: 14px;
}

 /* Button-Spalte */
#palette-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* Buttons wie echte Buttons */
#palette-buttons button {
  padding: 10px 14px;
  background: #2b2b2b;
  color: #fff;
  border: 1px solid #555;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  transition: background 0.15s, box-shadow 0.15s, transform 0.1s;
}

#palette-buttons button:hover {
  background: #3a3a3a;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

#palette-buttons button:active {
  transform: translateY(1px);
}


/* Button-Spalte */
#palette-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#palette-wrapper {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#palette-top-buttons {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
}

.palette-btn {
  padding: 8px 0;
  background: #2b2b2b;
  color: #fff;
  border: 1px solid #555;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.15s, box-shadow 0.15s;
}

.palette-btn:hover {
  background: #3a3a3a;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

.room-palette-item.active {
  border: 2px solid #00ff00;   /* leuchtendes Gr√ºn */
  box-shadow: 0 0 8px #00ff00; /* Glow-Effekt */
  transform: scale(1.05);      /* leicht vergr√∂√üern */
}

/* Upgrade Tooltip States */
.upgrade-ok {
  color: #4caf50; /* gr√ºn */
  font-weight: 600;
}

.upgrade-missing {
  color: #aaa;
}

.upgrade-title {
  margin-top: 6px;
  font-weight: bold;
  font-size: 12px;
}

.cell::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 70px;
  left: 50%;
  transform: translateX(-50%) rotate(-45deg);
  background: #111;
  color: #fff;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 11px;
  line-height: 1.3;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  z-index: 100;
  box-shadow: 0 0 10px rgba(0,0,0,0.8);
}

.cell:hover::after {
  opacity: 1;
}

#room-tooltip {
  position: fixed;
  background: #111;
  border: 1px solid #555;
  border-radius: 8px;
  padding: 10px 12px;
  font-size: 12px;
  color: #fff;
  pointer-events: none;
  z-index: 1000;
  max-width: 260px;
  box-shadow: 0 0 14px rgba(0,0,0,0.9);
  opacity: 0;
  transition: opacity 0.12s ease;
  
}

#room-tooltip strong {
  font-size: 13px;
}

#room-tooltip .upgrade-ok {
  color: #4caf50;
  font-weight: 600;
}

#room-tooltip .upgrade-missing {
  color: #aaa;
}

#room-tooltip .upgrade-title {
  margin-top: 6px;
  font-weight: bold;
  font-size: 12px;
  color: #fff;
}

	<!--CSS -->
 
</style>
</head>
<body>

 <h1 id="editor-title">PoE2 Atziri's Temple Planner - Tetriszocker</h1>
 
 <div id="editor-container">
  <!-- Grid links -->
  <div id="grid-container">
    <div id="grid"></div>
	
  </div>
  

  <!-- Sidebar rechts -->
  <div id="sidebar">
    <!-- Aktueller Raum -->
    <div id="current-room-display"></div>

	<div id="palette-and-buttons">

  <!-- PALETTE -->
  <div id="palette-wrapper">

   
    <!-- Deine bestehenden Raum-K√§stchen -->
    <div id="palette-container"></div>

  </div>

  <!-- FUNKTIONSBUTTONS -->
  <div id="palette-buttons">
    <button id="reset-button">Reset Grid</button>
    <button id="save-button">üíæ Save Layout</button>
    <button id="load-button">üìÇ Load Layout</button>
    <button id="export-button">üì§ Export as URL</button>
  </div>

</div>



    <!-- Effekte-Anzeige -->
    <div id="effects-display">
      <h3>Room Effects</h3>
      <div id="sidebar-content"></div>
    </div>
  </div>
  
  <div id="big-a">A</div>
  
</div>

<div id="room-tooltip"></div>
<script>
  
  // ------------------------------
// Mapping f√ºr Anzeige der Tier-Namen in Sidebar und Tooltip
const TIER_DISPLAY_NAME = {
  tier1: 'Tier 1',
  tier2: 'Tier 2',
  tier3: 'Tier 3',
  tier4: 'Transcendent 2',
  tier5: 'Transcendent 3',
  tier6: 'Legion 2',
  tier7: 'Legion 3'
};

function nextTier(tier) {
  const n = parseInt(tier.replace('tier',''));
  if (n >= 7) return null; // maximale Tierstufe erreicht
  return 'tier' + (n + 1);
}

// 1Ô∏è‚É£ ROOM_DATA (gek√ºrzt als Beispiel, alle 59 R√§ume k√∂nnen hier eingef√ºgt werden)
  // ------------------------------
  const ROOM_DATA = {

  // -------------------------
  // 1. Path
path: {
    id: 'path',
    name: 'Path',
    color: '#cccccc',
    tooltip: 'A simple path tile with no effects.',
    variants: {
      tier1: { effects: [] }
    },
    upgrades: {},
    //upgradeInfoFunction: (cellObj) => "No upgrades available"
},
  // -------------------------
  // 2. Garrison Group
  guardhouse: {
    id: 'guardhouse',
    name: 'Garrison',
    color: '#f28c8c',
    tooltip: 'Increased number of Monster Packs',
    variants: {
      tier1: { effects: ['10% increased number of Monster Packs'] },
      tier2: { effects: ['15% increased number of Monster Packs'] }, // Barracks
      tier3: { effects: ['20% increased number of Monster Packs'] },
	  tier4: { effects: ['Transcendent Barracks 2 - 30% increased number of Magic Monsters'] },
	  tier5: { effects: ['Transcendent Barracks 3 - 60% increased number of Magic Monsters'] },
	  tier6: { effects: ['Legion Barracks 2 - 30% increased number of Rare Monsters '] },
	  tier7: { effects: ['Legion Barracks 3 - 60% increased number of Rare Monsters '] },		 
    },
    upgrades: {
      tier2: { type: 'adjacent', rooms: ['commanders_chamber','armoury'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['commanders_chamber','armoury'], count: 2 },
	  tier4: { type: 'complex', requiredAdjacent: ['synthflesh_lab'], optionalAdjacent: ['armoury','commanders_chamber'], },
	  tier5: { type: 'adjacent', rooms: ['commanders_chamber','armoury', 'synthflesh_lab'], count: 3 },
	  tier6: { type: 'complex', requiredAdjacent: ['spymasters_study'], optionalAdjacent: ['armoury','commanders_chamber'], },
	  tier7: { type: 'adjacent', rooms: ['commanders_chamber','armoury', 'spymasters_study'], count: 3 },
    }
  },
  // -------------------------
  // 3. Commander Group
  commanders_chamber: {
    id: 'commanders_chamber',
    name: "Commander",
    color: '#f5a36f',
    tooltip: 'Effectiveness of Rare monsters',
    variants: {
      tier1: { effects: ['Rare Monsters have 15% increased effectiveness'] },
      tier2: { effects: ['Rare Monsters have 30% increased effectiveness'] },
      tier3: { effects: ['Rare Monsters have 60% increased effectiveness'] }
    },
    upgrades: {
      tier2: { type: 'adjacent', rooms: ['guardhouse',], count: 2 },
      tier3: { type: 'adjacent', rooms: ['guardhouse',], count: 3 }
    }
  },
  // -------------------------
  // 4. Armoury Group
  armoury: {
    id: 'armoury',
    name: 'Armoury',
    color: '#f5d36f',
    tooltip: 'Effectiveness of humanoid monsters',
    variants: {
      tier1: { effects: ['Humanoid Monsters have 15% increased effectiveness'] },
      tier2: { effects: ['Humanoid Monsters have 30% increased effectiveness'] },
      tier3: { effects: ['Humanoid Monsters have 60% increased effectiveness'] }
    },
    upgrades: {
      tier2: { type: 'adjacent', rooms: ['bronzeworks', 'chamber_of_souls'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['bronzeworks', 'chamber_of_souls'], count: 2 }
    }
  },
  // -------------------------
  // 5. Smithy Group
bronzeworks: {
    id: 'bronzeworks',
    name: 'Smithy',
    color: '#fc8c6f',
    tooltip: 'Increases chest item rarity',
    variants: {
      tier1: { effects: ['Chests have 15% more item rarity'] },
      tier2: { effects: ['Chests have 30% more item rarity'] },
      tier3: { effects: ['Chests have 60% more item rarity'] }
    },
    upgrades: {},
    upgradeInfoFunction: (cellObj) => "Requires Golem Works adjacent and Generator in range to upgrade"
},

  // -------------------------
  // 6. Generator Group
  dynamo: {
  id: 'dynamo',
  name: 'Generator',
  color: '#8fcaf2',
  tooltip: 'Required for Smithy, Synth Lab, Transc Barracks and 2x for Workshop Upgrades',
  providesEnergy: true,
  energyRangeByTier: {
    tier1: 3,
    tier2: 4,
    tier3: 5
  },
  variants: {
    tier1: { effects: ['Construct Monsters have 15% increased effectiveness'] },
    tier2: { effects: ['Construct Monsters have 30% increased effectiveness'] },
    tier3: { effects: ['Construct Monsters have 60% increased effectiveness'] }
  },
  upgrades: {
    tier2: { type: 'adjacent', rooms: ['thaumaturges_laboratory', 'altar_of_sacrifice'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['thaumaturges_laboratory', 'altar_of_sacrifice'], count: 2 }
  }
},

  // -------------------------
  // 7. Spymaster Group
spymasters_study: {
    id: 'spymasters_study',
    name: "Spymaster",
    color: '#6fcf6f',
    tooltip: 'Increases Temple Mod effects. Upgrades by assassinating other Spymasters',
    variants: {
      tier1: { effects: ['8% increased effect of Temple Mods ...'] },
      tier2: { effects: ['15% increased effect of Temple Mods ...'] },
      tier3: { effects: ['30% increased effect of Temple Mods ...'] }
    },
    upgrades: {},
    upgradeInfoFunction: (cellObj) => "Spymaster upgrades by assassinating other Spymasters. For the editor, place the Spymaster then click on the desired Tier"
},
  // -------------------------
  // 9. Synthflesh Lab Group
  synthflesh_lab: {
    id: 'synthflesh_lab',
    name: 'Synth Lab',
    color: '#cf6fcf',
    tooltip: 'Increases exp gain',
    variants: {
      tier1: { effects: ['10% inc. exp'] },
      tier2: { effects: ['20% inc. exp'] },
      tier3: { effects: ['40% inc. exp'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['surgeons_ward', 'dynamo'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['surgeons_ward', 'dynamo'], count: 2 }
	 
    }
  },
  // -------------------------
  // 10. Flesh Surgeon Group
  surgeons_ward: {
    id: 'surgeons_ward',
    name: "Flesh Surgeon",
    color: '#cf8c6f',
    tooltip: 'Effectiveness of unique Monsters',
    variants: {
      tier1: { effects: ['10% Unique Monster Effectiveness'] },
      tier2: { effects: ['20% Unique Monster Effectiveness'] },
      tier3: { effects: ['40% Unique Monster Effectiveness. Gives Limp Mod.'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['synthflesh_lab'], minTier: 0, count: 1 },
    tier3: { type: 'adjacent', rooms: ['synthflesh_lab'], minTier: 1, count: 1 }
	}
  },
  // -------------------------
  // 11. Golem Works Group
  workshop: {
    id: 'workshop',
    name: 'Golem Works',
    color: '#8cf2cf',
	tooltip: 'increased effect of Temple Mods from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs',
    variants: {
      tier1: { effects: ['8% increased effect of Temple Mods from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs'] },
      tier2: { effects: ['15% increased effect of Temple Mods from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs'] },
      tier3: { effects: ['30% increased effect of Temple Mods from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs'] }
    },
    upgrades: {   },
	  upgradeInfoFunction: (cellObj) => "Needs 2 Generators in range to upgrade to Tier3"
  },
  // -------------------------
  // 12. Alchemy Lab Group
  chamber_of_souls: {
    id: 'chamber_of_souls',
    name: 'Alchemy Lab',
    color: '#f2cf6f',
    tooltip: 'Item rarity on Monsters',
    variants: {
      tier1: { effects: ['15% increased item rarity'] },
      tier2: { effects: ['30% increased item rarity'] },
      tier3: { effects: ['60% increased item rarity. Corrupt Soul Cores'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['thaumaturges_laboratory'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['thaumaturges_laboratory'], count: 2 }
	}
  },
  // -------------------------
  // 13. Thaumaturge Group
  thaumaturges_laboratory: {
    id: 'thaumaturges_laboratory',
    name: "Thaumaturge's",
    color: '#6ff2cf',
    tooltip: 'Increased effect of Temple Mods from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers',
    variants: {
      tier1: { effects: ['8% increased effect of Temple Mods from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers'] },
      tier2: { effects: ['15% increased effect of Temple Mods from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers'] },
      tier3: { effects: ['Area contains an additional Quadrilla Sergeant. 30% increased effect of Temple Mods from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers'] }
    },
    upgrades: {
	  tier2: { type: 'adjacent', rooms: ['altar_of_sacrifice'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['altar_of_sacrifice'], count: 2 }
	}
  },
  // -------------------------
  // 14. Corruption Chamber Group
  crimson_hall: {
    id: 'crimson_hall',
    name: 'Corruption Chamber',
    color: '#f26fcf',
    tooltip: 'Rare Monsters have a 15% chance to have an additional Modifier',
    variants: {
      tier1: { effects: ['Rare Monsters have a 15% chance to have an additional Modifier'] },
      tier2: { effects: ['Rare Monsters have a 30% chance to have an additional Modifier'] },
      tier3: { effects: ['Area contains an additional Royal Sentinel. Rare Monsters have a 60% chance to have an additional Modifier'] }
    },
    upgrades: {
	  tier2: { type: 'adjacent', rooms: ['altar_of_sacrifice', 'thaumaturges_laboratory'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['altar_of_sacrifice', 'thaumaturges_laboratory'], count: 2 }}
  },

  // -------------------------
  // 15. Sacrificial Chamber Group
  altar_of_sacrifice: {
    id: 'altar_of_sacrifice',
    name: 'Sacrifical Chamber',
	color: '#6f6f6f',
    tooltip: 'More rare Chests',
    variants: {
      tier1: { effects: ['15% increased amount of Rare Chests'] },
      tier2: { effects: ['15% increased amount of Rare Chests'] },
      tier3: { effects: ['60% increased amount of Rare Chests. Area contains an additional Unchained Beast'] }
    },
    upgrades: {},
	upgradeInfoFunction: (cellObj) => "Upgrades by sacrificing another room."
  },

  // -------------------------
  // 16. Reward Rooms (Joker)
  joker: {
    id: 'joker',
    name: 'Reward Room',
	color: '#ffffff',
    tooltip: 'Special reward room. No effect.',
    variants: {
      tier1: { effects: [] }
    },
    upgrades: {},
	upgradeInfoFunction: (cellObj) => "No upgrades available"
  },
  
   // 17. Clean Tile 
  Clean: {
    id: 'Clean',
    name: 'Clean Tile',
    color: '#111',
    tooltip: '',
	showTooltip: false,
    variants: {
      tier1: { effects: [] }
    },
    upgrades: {},
	upgradeInfoFunction: (cellObj) => "No upgrades available"
  }
};

// ------------------------------
// Raum ‚Üî Code Mapping
const ROOM_CODE_MAP = {
  path: "P",
  guardhouse: "G",
  commanders_chamber: "C",
  armoury: "A",
  bronzeworks: "B",
  dynamo: "D",
  spymasters_study: "S",
  synthflesh_lab: "Y",
  surgeons_ward: "F",
  workshop: "W",
  chamber_of_souls: "L",
  thaumaturges_laboratory: "T",
  crimson_hall: "R",
  altar_of_sacrifice: "Z",
  joker: "J",
  Clean: "_"
};

const CODE_ROOM_MAP = Object.fromEntries(
  Object.entries(ROOM_CODE_MAP).map(([k, v]) => [v, k])
);

const GENERATOR_ROOMS = ['dynamo'];

 // ------------------------------
// 2. Globale Variable f√ºr aktuell ausgew√§hlten Raum
let current = ROOM_DATA['path']; 

const sidebarContent = document.getElementById("sidebar-content");
const tooltipEl = document.getElementById("room-tooltip");


let selectedCell = null; // speichert die aktuell ausgew√§hlte Zelle auf dem Grid


// ------------------------------
// 3. Aktueller Raum anzeigen
const currentRoomEl = document.getElementById('current-room-display');
function updateCurrentRoomDisplay() {
  currentRoomEl.innerText = current.name;
  currentRoomEl.title = current.tooltip;
}
updateCurrentRoomDisplay();

// ------------------------------
// 4. Palette erstellen
const paletteContainer = document.getElementById('palette-container');

// Palette durchlaufen
for (const roomId in ROOM_DATA) {
  const room = ROOM_DATA[roomId];
  const el = document.createElement('div');
  el.classList.add('room-palette-item');
  el.style.backgroundColor = room.color;

  const roomLabel = document.createElement('div');
  roomLabel.innerText = room.name;
  roomLabel.style.pointerEvents = 'none';
  el.appendChild(roomLabel);

  el.dataset.roomId = roomId;
  el.title = room.tooltip;

  // Haupt-Button klickt Raum ausw√§hlen
  el.onclick = () => {
    current = ROOM_DATA[roomId];
    updateCurrentRoomDisplay();
    updateGeneratorRanges();

    document.querySelectorAll('.room-palette-item').forEach(item => item.classList.remove('active'));
    el.classList.add('active');
  };

  // Tier-Buttons nur f√ºr Spymaster & Sacrificial Chamber
  if (roomId === 'spymasters_study' || roomId === 'altar_of_sacrifice') {
    const tierContainer = document.createElement('div');
    tierContainer.style.display = 'flex';
    tierContainer.style.justifyContent = 'center';
    tierContainer.style.marginTop = '4px';
    tierContainer.style.gap = '4px';

    ['tier1','tier2','tier3'].forEach(tier => {
      const btn = document.createElement('button');
      btn.innerText = tier.replace('tier','T');
      btn.style.fontSize = '10px';
      btn.style.padding = '2px 4px';
      btn.style.cursor = 'pointer';



      btn.onclick = (e) => {
    e.stopPropagation(); // verhindert, dass Palette auch klickt
    if (!selectedCell) return; // keine Zelle ausgew√§hlt
    // ‚ö° Tier nur auf Spymaster oder Sacrificial Chamber anwenden
    if ( selectedCell &&  ( selectedCell.room === 'spymasters_study' ||  
							selectedCell.room === 'altar_of_sacrifice')
		) { 

        selectedCell.tier = tier;
        selectedCell.manualTier = true; // markiert, dass Tier manuell gesetzt wurde
        renderCell(selectedCell);       // aktualisiert die Zelle optisch
        updateEffectsSidebar();         // aktualisiert Sidebar-Effekte
    }
	
		else { return; // ‚ùå KEINE anderen R√§ume
}
};

      tierContainer.appendChild(btn);
    });

    el.appendChild(tierContainer);
  }

  paletteContainer.appendChild(el);
}

// ------------------------------
// 5. Grid erstellen
const gridEl = document.getElementById("grid");
const gridSize = 9;
let grid = [];

for (let y = 0; y < gridSize; y++) {
  let row = [];
  for (let x = 0; x < gridSize; x++) {
    const cell = document.createElement("div");
    cell.classList.add("cell");
    cell.dataset.x = x;
    cell.dataset.y = y;

    const cellObj = { el: cell, room: 'Clean', tier: 'tier1', manualTier: false, x, y };

    // Zelle ins Grid
    gridEl.appendChild(cell);
    row.push(cellObj);

    // Tooltip Event-Listener
    cell.addEventListener("mouseenter", () => {
  const cellObj = grid[y][x];
  const roomData = ROOM_DATA[cellObj.room];
  if (!roomData) return;

  const displayTier = TIER_DISPLAY_NAME[cellObj.tier] || cellObj.tier;
  
  // Anforderungen f√ºr das n√§chste Upgrade
const next = nextTier(cellObj.tier);
let upgradeText = "No upgrades available";

// ‚úÖ zuerst pr√ºfen, ob upgradeInfoFunction existiert
if (roomData.upgradeInfoFunction) {
    upgradeText = roomData.upgradeInfoFunction(cellObj);
} 
// ansonsten bestehende room.upgrades pr√ºfen
else {
    const next = nextTier(cellObj.tier);
    if (next && roomData.upgrades?.[next]) {
        const upgrade = roomData.upgrades[next];
        if (upgrade.type === "adjacent") {
            upgradeText = `${TIER_DISPLAY_NAME[next]}: Adjacent Rooms required: ${upgrade.rooms.map(id => ROOM_DATA[id]?.name || id).join(", ")} (at least ${upgrade.count})`;
        } else if (upgrade.type === "complex") {
            upgradeText = `${TIER_DISPLAY_NAME[next]}: Requires ${upgrade.requiredAdjacent.map(id => ROOM_DATA[id]?.name || id).join(", ")}, and: ${upgrade.optionalAdjacent.map(id => ROOM_DATA[id]?.name || id).join(", ")}`;
        }
    }
}


  tooltipEl.innerHTML = `
    <strong>${roomData.name}</strong><br>
    Tier: ${displayTier}<br>
    ${upgradeText}
  `;
  tooltipEl.style.opacity = "1";
});

    cell.addEventListener("mousemove", (e) => {
      tooltipEl.style.left = e.clientX + 20 + "px";
      tooltipEl.style.top  = e.clientY - 10 + "px";
    });

    cell.addEventListener("mouseleave", () => {
      tooltipEl.style.opacity = "0";
    });

    // Klick zum Platzieren
    cell.onclick = () => placeRoom(x, y);
  }
  grid.push(row);
}

  positionBigA();

  window.addEventListener('resize', positionBigA);

function positionBigA() {
  const bigA = document.getElementById('big-a');

  const gridRect = gridEl.getBoundingClientRect();
  const gridSize = 9;
  const cellWidth = gridRect.width / gridSize;
  const cellHeight = gridRect.height / gridSize;

  // Wir wollen es "oben rechts auf der Diagonale" platzieren
  // Das entspricht ungef√§hr etwas oberhalb der Zelle [0][4]
  const diagonalIndex = 3;

  const top = cellHeight * diagonalIndex * 0.6; // etwas oberhalb
  const left = cellWidth * (gridSize - 1 - diagonalIndex) * 1.4; // leicht rechts

  bigA.style.top = `${gridRect.top + top}px`;
  bigA.style.left = `${gridRect.left + left}px`;
}


positionBigA();
window.addEventListener('resize', positionBigA);

// ------------------------------
// Generator-Reichweite nach Tier
function getGeneratorRange(tier) {
  const t = parseInt(tier.replace('tier',''));
  return 2 + t; // Tier1 = 3 Felder, Tier2 = 4, Tier3 = 5
}

// ------------------------------
// 6. Funktion zum Setzen eines Raums in der Zelle
function placeRoom(x, y) {
  if (!current) return;

  const cellObj = grid[y][x];
  selectedCell = cellObj;

  // üîπ WENN Clean gesetzt wird ‚Üí kompletter Reset
  if (current.id === 'Clean') {
    cellObj.room = 'Clean';
    cellObj.tier = 'tier1';
    cellObj.manualTier = false;
    renderCell(cellObj);

    recalcAllTiers();
    updateGeneratorRanges();
    updateEffectsSidebar();
    return;
  }

  // üîπ Normaler Raum
  cellObj.room = current.id;
  cellObj.tier = 'tier1';
  cellObj.manualTier = false;

  renderCell(cellObj);

  recalcAllTiers();
  updateGeneratorRanges();
  updateEffectsSidebar();
}

function updateTier(x, y) {
    const cellObj = grid[y][x];
    if (!cellObj.room) return;

    const room = ROOM_DATA[cellObj.room];
    let newTier = 'tier1';

    const neighbors = [
        [x-1, y], [x+1, y], [x, y-1], [x, y+1]
    ];

    // Manuell gesetzte Tiers oder spezielle R√§ume
    if (cellObj.manualTier) {
        renderCell(cellObj);
        return;
    }

    if (cellObj.room === 'spymasters_study' || cellObj.room === 'altar_of_sacrifice') {
        cellObj.tier = 'tier1';
        renderCell(cellObj);
        return;
    }

    // --------------------------
    // Spymaster
    if (cellObj.room === 'spymasters_study') {
        let tier = 'tier1';
        const removedSpymasters = neighbors.reduce((count,[nx,ny])=>{
            const n = grid[ny]?.[nx];
            if(!n) return count;
            if(n.room === 'Clean') return count+1;
            return count;
        },0);
        if (removedSpymasters >= 2) tier = 'tier3';
        else if (removedSpymasters >= 1) tier = 'tier2';
        cellObj.tier = tier;
        renderCell(cellObj);
        return;
    }

    // --------------------------
    // Altar of Sacrifice
    if (cellObj.room === 'altar_of_sacrifice') {
        let tier = 'tier1';
        const removedSpymasters = neighbors.reduce((count,[nx,ny])=>{
            const n = grid[ny]?.[nx];
            if(!n) return count;
            if(n.room === 'Clean') return count+1;
            return count;
        },0);
        if (removedSpymasters >= 2) tier = 'tier3';
        else if (removedSpymasters >= 1) tier = 'tier2';
        cellObj.tier = tier;
        renderCell(cellObj);
        return;
    }

    // --------------------------
    // Thaumaturge
    if (cellObj.room === 'thaumaturges_laboratory') {
        let tier = 'tier1';
        const sacrificialNeighbors = neighbors
            .map(([nx, ny]) => grid[ny]?.[nx])
            .filter(n => n && n.room === 'altar_of_sacrifice');

        const hasTier3Altar = sacrificialNeighbors.some(n => n.tier === 'tier3');
        const altarCount = sacrificialNeighbors.length;

        if (hasTier3Altar || altarCount >= 2) tier = 'tier3';
        else if (altarCount >= 1) tier = 'tier2';

        cellObj.tier = tier;
        renderCell(cellObj);
        return;
    }

    // --------------------------
    // Commander
    if (cellObj.room === 'commanders_chamber') {
        let tier = 'tier1';
        let guardhouseCount = 0;
        neighbors.forEach(([nx, ny]) => {
            const neighbor = grid[ny]?.[nx];
            if (!neighbor) return;
            if (neighbor.room === 'guardhouse') guardhouseCount++;
        });
        if (guardhouseCount >= 3) tier = 'tier3';
        else if (guardhouseCount >= 2) tier = 'tier2';
        cellObj.tier = tier;
        renderCell(cellObj);
        return;
    }

    // --------------------------
    // Bronzeworks (Smithy)
    if (cellObj.room === 'bronzeworks') {
        let tier = 'tier1';
        const hasWorkshopAdjacent = neighbors.some(([nx, ny]) => {
            const n = grid[ny]?.[nx];
            return n && n.room === 'workshop';
        });
        const hasGeneratorInRange = countPoweringGenerators(x, y) > 0;

        if (hasWorkshopAdjacent || hasGeneratorInRange) tier = 'tier2';
        if (hasWorkshopAdjacent && hasGeneratorInRange) tier = 'tier3';

        cellObj.tier = tier;
        renderCell(cellObj);
        return;
    }

    // --------------------------
    // Surgeons Ward
    if (cellObj.room === 'surgeons_ward') {
        let tier = 'tier1';
        const synthLabs = neighbors
            .map(([nx, ny]) => grid[ny]?.[nx])
            .filter(n => n && n.room === 'synthflesh_lab');

        if (synthLabs.length >= 1) tier = 'tier2';
        const hasTier3Synth = synthLabs.some(n => n.tier === 'tier3');
        if (synthLabs.length >= 2 || hasTier3Synth) tier = 'tier3';

        cellObj.tier = tier;
        renderCell(cellObj);
        return;
    }

    // --------------------------
    // Synthflesh Lab
    if (cellObj.room === 'synthflesh_lab') {
        let tier = 'tier1';
        const surgeonNeighbors = neighbors
            .map(([nx,ny]) => grid[ny]?.[nx])
            .filter(n => n && n.room === 'surgeons_ward');
        const hasSurgeon = surgeonNeighbors.length > 0;
        const genNearby = countPoweringGenerators(x, y) > 0;

        if (genNearby || hasSurgeon) tier = 'tier2';
        if (genNearby && surgeonNeighbors.some(n => n.tier === 'tier2' || n.tier === 'tier3')) tier = 'tier3';

        cellObj.tier = tier;
        renderCell(cellObj);

        surgeonNeighbors.forEach(n => {
            if (!n.manualTier && maxTier(n.tier, 'tier2') !== n.tier) {
                n.tier = 'tier2';
                renderCell(n);
            }
        });
        return;
    }

    // --------------------------
    // Golem Works
    if (cellObj.room === 'workshop') {
        let tier = 'tier1';
        const genCount = countPoweringGenerators(x, y);
        if (genCount >= 2) tier = 'tier3';
        else if (genCount >= 1) tier = 'tier2';

        cellObj.tier = tier;
        renderCell(cellObj);
        return;
    }

  
    // --------------------------
    // Adjacent / Complex Upgrades
    const roomUpgrades = room.upgrades || {};
    let maxTierAchieved = 'tier1';

    for (const tierKey in roomUpgrades) {
        const upgrade = roomUpgrades[tierKey];

        if (upgrade.type === 'adjacent') {
            let count = 0;
            neighbors.forEach(([nx, ny]) => {
                const neighbor = grid[ny]?.[nx];
                if (!neighbor) return;
                if (upgrade.rooms.includes(neighbor.room)) count++;
            });
            if (count >= upgrade.count) {
                maxTierAchieved = maxTier(maxTierAchieved, tierKey);
            }
        }

        if (upgrade.type === 'complex') {
            const adjacentRooms = neighbors
                .map(([nx,ny]) => grid[ny]?.[nx]?.room)
                .filter(r => r);
            const hasRequired = upgrade.requiredAdjacent.every(r => adjacentRooms.includes(r));
            const hasOptional = upgrade.optionalAdjacent.some(r => adjacentRooms.includes(r));
            if (hasRequired && hasOptional) {
                maxTierAchieved = maxTier(maxTierAchieved, tierKey);
            }
        }
    }

    cellObj.tier = maxTierAchieved;
    renderCell(cellObj);
}


				// UPdatetier fertig //

function recalcAllTiers() {
  // 1Ô∏è‚É£ Alle automatischen Tiers zur√ºcksetzen
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const c = grid[y][x];
      if (c.room === 'Clean') continue;
      if (!c.manualTier) {
        c.tier = 'tier1';
      }
    }
  }

  // 2Ô∏è‚É£ Mehrfach neu berechnen (Abh√§ngigkeiten!)
  for (let pass = 0; pass < 3; pass++) {
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        updateTier(x, y);
        updateGuardhouseVariant(x, y);
      }
    }
  }
}

// Hilfsfunktion: h√∂heres Tier
function maxTier(t1, t2) {
    const n1 = parseInt(t1.replace('tier',''));
    const n2 = parseInt(t2.replace('tier',''));
    return n1 >= n2 ? t1 : t2;
}

// renderCell anpassen f√ºr Sidebar/Tooltip
function renderCell(cellObj) {
  if (!ROOM_DATA[cellObj.room]) return;

  const room = ROOM_DATA[cellObj.room];
  cellObj.el.style.backgroundColor = room.color;

  const effects = room.variants[cellObj.tier]?.effects || [];
  const displayTier = TIER_DISPLAY_NAME[cellObj.tier] || cellObj.tier;

  //cellObj.el.title = `${room.name} (${displayTier})\n${effects.join('\n')}`;

  let innerHTML = '';

  if (cellObj.room === 'Clean') {
    innerHTML = '';
  } else if (['tier4','tier5','tier6','tier7'].includes(cellObj.tier)) {
    let tierShort = displayTier.split(' ')[1] || displayTier;
    if (displayTier.includes('Transcendent')) tierShort = 'T' + tierShort;
    if (displayTier.includes('Legion')) tierShort = 'L' + tierShort;

    innerHTML = `<span class="room-initial">${tierShort}</span>`;
  } else {
    const words = room.name.split(" ");
    let initials = words.map(w => w[0]).join("");
    if (initials.length > 2) initials = initials.slice(0,2);

    innerHTML = `<span class="room-initial">${initials}</span>`;
    innerHTML += `<span class="tier-number">${cellObj.tier.replace('tier','')}</span>`;
  }

  cellObj.el.innerHTML = innerHTML;

  if (!hasRequiredEnergy(cellObj)) {
    cellObj.el.classList.add("no-power");
  } else {
    cellObj.el.classList.remove("no-power");
  }
   
}

function updateGuardhouseVariant(x, y) {
  const cellObj = grid[y][x];
  if (!cellObj.room || cellObj.room !== 'guardhouse') return;

  const neighbors = [
    [x-1,y], [x+1,y], [x,y-1], [x,y+1]
  ];

  // Liste der angrenzenden Raum-IDs
  let adjacentRooms = neighbors
    .map(([nx,ny]) => grid[ny]?.[nx]?.room)
    .filter(r => r);

  let newTier = 'tier1';
  const room = ROOM_DATA['guardhouse'];

  // -----------------------------
  // 1Ô∏è‚É£ Normale Adjacent-Tiers pr√ºfen
  for (const tier in room.upgrades) {
    const upgrade = room.upgrades[tier];

    if (upgrade.type === 'adjacent') {
      let count = 0;
      upgrade.rooms.forEach(r => {
        if (adjacentRooms.includes(r)) count++;
      });
      if (count >= upgrade.count) newTier = tier;
    }

    // -----------------------------
    // 2Ô∏è‚É£ Komplexe Upgrades pr√ºfen (Tier4, Tier6)
    if (upgrade.type === 'complex') {
      const hasRequired = upgrade.requiredAdjacent.every(r => adjacentRooms.includes(r));
      const hasOptional = upgrade.optionalAdjacent.some(r => adjacentRooms.includes(r));
      if (hasRequired && hasOptional) newTier = tier;
    }
  }

  cellObj.tier = newTier;
  renderCell(cellObj);
}

function countConnectedGenerators(x, y) {
  const visited = new Set();
  const stack = [[x, y]];
  let generators = 0;

  while (stack.length) {
    const [cx, cy] = stack.pop();
    const key = `${cx},${cy}`;
    if (visited.has(key)) continue;
    visited.add(key);

    const cell = grid[cy]?.[cx];
    if (!cell) continue;

    if (GENERATOR_ROOMS.includes(cell.room)) {
      generators++;
      continue;
    }

  // Energie kann durch alle R√§ume flie√üen (au√üer au√üerhalb des Grids)


    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy]) => {
      stack.push([cx+dx, cy+dy]);
    });
  }

  return generators;
}

function distance(a, b) {
  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

function getActiveGenerators() {
  const generators = [];

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      if (cell.room === "dynamo") {
        generators.push(cell);
      }
    }
  }

  return generators;
}

function getGeneratorBonusForCell(targetCell) {
  const generators = getActiveGenerators();
  let bonus = 0;

  generators.forEach(gen => {
    const maxRange = getGeneratorRange(gen.tier);

    const visited = new Set();
    const queue = [{ x: gen.x, y: gen.y, distance: 0 }];
    let reachesTarget = false;

    while (queue.length && !reachesTarget) {
      const { x, y, distance } = queue.shift();
      const key = `${x},${y}`;
      if (visited.has(key)) continue;
      visited.add(key);

      if (x === targetCell.x && y === targetCell.y) {
        reachesTarget = true;
        break;
      }

      if (distance >= maxRange) continue;

      const neighbors = [
        [x+1,y], [x-1,y], [x,y+1], [x,y-1]
      ];

      neighbors.forEach(([nx, ny]) => {
        const cell = grid[ny]?.[nx];
        if (!cell) return;
        // Energie flie√üt durch alle R√§ume, au√üer leere Tiles blockieren evtl.
        if (cell.room !== 'Clean') {
          queue.push({ x: nx, y: ny, distance: distance+1 });
        }
      });
    }

    if (reachesTarget) {
      const room = ROOM_DATA["dynamo"];
      const tierEffects = room.variants[gen.tier]?.effects || [];
      tierEffects.forEach(effect => {
        const match = effect.match(/(\d+)%/);
        if (match) bonus += parseInt(match[1]);
      });
    }
  });

  return bonus;
}



		//UpdateEffectsSidebar//
function updateEffectsSidebar() {
  sidebarContent.innerHTML = "";

  // 1Ô∏è‚É£ R√§ume nach roomId + tier gruppieren
  const grouped = {};

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      if (!cell.room || cell.room === 'Clean') continue;

      const room = ROOM_DATA[cell.room];
      const tier = cell.tier;
      const hasPower = hasRequiredEnergy(cell);

      const key = `${cell.room}-${tier}`;

      if (!grouped[key]) {
        grouped[key] = {
          room: room,
          tier: tier,
          cells: [],
          hasPower: hasPower
        };
      }
      grouped[key].cells.push(cell);
      if (!hasPower) grouped[key].hasPower = false;
    }
  }

  // 2Ô∏è‚É£ Jede Gruppe in der Sidebar darstellen
  for (const key in grouped) {
    const group = grouped[key];
    const room = group.room;
    const tierData = room.variants[group.tier];
    if (!tierData) continue;

    const count = group.cells.length;
    const hasPower = group.hasPower;

    const roomBlock = document.createElement("div");
    roomBlock.style.marginBottom = "12px";

    // √úberschrift mit Anzahl und Gesamt-Effekt
    const title = document.createElement("strong");
    const displayTier = TIER_DISPLAY_NAME[group.tier] || group.tier;

    let totalEffectText = "";
    if (tierData.effects.length > 0) {
      const percentMatch = tierData.effects[0].match(/(\d+)%/);
      if (percentMatch) {
        const perRoom = parseInt(percentMatch[1]);
        const total = perRoom * count;
        totalEffectText = `${total}% ${tierData.effects[0].replace(/^\d+% /, '')}`;
      }
    }

    title.innerText = `${room.name} (${displayTier}) x${count} = ${totalEffectText}`;
    title.style.color = hasPower ? "#fff" : "#ff5555";
    roomBlock.appendChild(title);

    // Einzelne Effekte auflisten
    const ul = document.createElement("ul");
    ul.style.margin = "4px 0 0 12px";

    for (let i = 0; i < count; i++) {
      tierData.effects.forEach(effect => {
        const li = document.createElement("li");
        li.innerText = effect;

        // ‚úÖ Farbe der Effekte: gr√ºn, wenn aktiv, rot, wenn keine Energie
        li.style.color = hasPower ? "#00ff00" : "#ff5555";

        ul.appendChild(li);
      });
    }

    roomBlock.appendChild(ul);

    // Warnung, wenn keine Energie
    if (!hasPower) {
      const warning = document.createElement("div");
      warning.innerText = "‚ö† Needs Dynamo in range to work";
      warning.style.color = "#ff5555";
      warning.style.fontSize = "11px";
      warning.style.marginTop = "4px";
      warning.style.fontStyle = "italic";
      roomBlock.appendChild(warning);
    }

    sidebarContent.appendChild(roomBlock);
  }

  if (sidebarContent.innerHTML === "") {
    sidebarContent.innerHTML = "<em>No room effects yet.</em>";
  }
}

const resetButton = document.getElementById("reset-button");

resetButton.onclick = () => {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cellObj = grid[y][x];
      cellObj.room = 'Clean';
      cellObj.tier = 'tier1';
	  cellObj.manualTier = false;

      renderCell(cellObj);
    }
  }

  // Alles neu berechnen
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      recalcAllTiers();

    }
  }

  updateGeneratorRanges();
  updateEffectsSidebar();

  // Optional: aktive Palette abw√§hlen
  document.querySelectorAll('.room-palette-item').forEach(item => {
    item.classList.remove('active');
  });
};

const saveButton = document.getElementById("save-button");
const loadButton = document.getElementById("load-button");
const exportButton = document.getElementById("export-button");

saveButton.onclick = saveLayout;
loadButton.onclick = loadLayout;
exportButton.onclick = exportLayoutAsLink;

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cellObj = grid[y][x];
      cellObj.room = 'Clean';
      cellObj.tier = 'tier1';
	  cellObj.manualTier = false;

      renderCell(cellObj);
    }
  }
  updateEffectsSidebar();


function countPoweringGenerators(x, y) {
    let count = 0;
    const generators = getActiveGenerators();

    generators.forEach(gen => {
        const maxRange = getGeneratorRange(gen.tier);
        const visited = new Set();
        const queue = [{ x: gen.x, y: gen.y, distance: 0 }];

        while (queue.length) {
            const { x: cx, y: cy, distance } = queue.shift();
            const key = `${cx},${cy}`;
            if (visited.has(key)) continue;
            visited.add(key);

            if (distance > maxRange) continue;

            const cell = grid[cy]?.[cx];
            if (!cell) continue;

            // Generator selbst ‚Üí Startpunkt
            if (cx === gen.x && cy === gen.y) {
                // darf weiterlaufen
            } 
            // Ziel erreicht
            else if (cx === x && cy === y) {
                count++;
                break;
            } 
            // Energie darf nur √ºber Pfade flie√üen
            else if (cell.room !== 'path') {
                continue;
            }

            // Nachbarn pr√ºfen
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx, dy]) => {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                    queue.push({ x: nx, y: ny, distance: distance + 1 });
                }
            });
        }
    });

    return count;
}






 
// Pr√ºft, ob die Zelle gen√ºgend Generator-Energie hat
function hasRequiredEnergy(cellObj) {
    const roomId = cellObj.room;
    // Nur bestimmte R√§ume ben√∂tigen Generator
    const roomsNeedingGenerator = ['workshop', 'bronzeworks', 'synthflesh_lab'];

    if (!roomsNeedingGenerator.includes(roomId)) {
        return true; // alle anderen R√§ume haben immer "genug Energie"
    }

    const genCount = countPoweringGenerators(cellObj.x, cellObj.y);

    // Workshop: Tier3 = 2 Generatoren, Tier2 = 1 Generator
    if (roomId === 'workshop') {
        if (cellObj.tier === 'tier3') return genCount >= 2;
        if (cellObj.tier === 'tier2') return genCount >= 1;
        return true;
    }

    // Bronzeworks: Tier3 = Workshop + Generator, Tier2 = Workshop oder Generator
    if (roomId === 'bronzeworks') {
        const neighbors = [
            [cellObj.x-1, cellObj.y], [cellObj.x+1, cellObj.y], 
            [cellObj.x, cellObj.y-1], [cellObj.x, cellObj.y+1]
        ];
        const hasWorkshopAdjacent = neighbors.some(([nx, ny]) => {
            const n = grid[ny]?.[nx];
            return n && n.room === 'workshop';
        });

        if (cellObj.tier === 'tier3') return hasWorkshopAdjacent && genCount > 0;
        if (cellObj.tier === 'tier2') return hasWorkshopAdjacent || genCount > 0;
        return true;
    }

    // Synthflesh Lab: Tier3 = Surgeon + Generator, Tier2 = Surgeon oder Generator
    if (roomId === 'synthflesh_lab') {
        const neighbors = [
            [cellObj.x-1, cellObj.y], [cellObj.x+1, cellObj.y], 
            [cellObj.x, cellObj.y-1], [cellObj.x, cellObj.y+1]
        ];
        const hasSurgeonAdjacent = neighbors.some(([nx, ny]) => {
            const n = grid[ny]?.[nx];
            return n && n.room === 'surgeons_ward';
        });

        if (cellObj.tier === 'tier3') return hasSurgeonAdjacent && genCount > 0;
        if (cellObj.tier === 'tier2') return hasSurgeonAdjacent || genCount > 0;
        return true;
    }

    return true; // Default
}




function updateGeneratorRanges() {
  // alles zur√ºcksetzen
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      grid[y][x].el.classList.remove("generator-edge");
      grid[y][x].inGeneratorRange = false;
    }
  }

  if (!current || current.id !== "dynamo") return;

  const generators = getActiveGenerators();

  generators.forEach(gen => {
    const genRoom = ROOM_DATA[gen.room];
	const range = genRoom.energyRangeByTier[gen.tier] || 0;

    // 1Ô∏è‚É£ Reichweite markieren
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (distance(gen, grid[y][x]) <= range) {
          grid[y][x].inGeneratorRange = true;
        }
      }
    }
  });

  // 2Ô∏è‚É£ Nur √§u√üere Kante markieren
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      if (!cell.inGeneratorRange) continue;

      const neighbors = [
        [x-1,y], [x+1,y], [x,y-1], [x,y+1]
      ];

      const isEdge = neighbors.some(([nx, ny]) =>
        !grid[ny]?.[nx]?.inGeneratorRange
      );

      if (isEdge) {
        cell.el.classList.add("generator-edge");
      }
    }
  }
}

// ------------------------------
// üíæ Layout speichern
function saveLayout() {
  const layout = [];

  for (let y = 0; y < gridSize; y++) {
    layout[y] = [];
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      layout[y][x] = {
        room: cell.room,
        tier: cell.tier
      };
    }
  }

  localStorage.setItem("atziriTempleLayout", JSON.stringify(layout));
  alert("Layout gespeichert!");
}

// ------------------------------
// üìÇ Layout laden
function loadLayout() {
  const raw = localStorage.getItem("atziriTempleLayout");
  if (!raw) {
    alert("Kein gespeichertes Layout gefunden");
    return;
  }

  const layout = JSON.parse(raw);

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const saved = layout[y][x];
      const cell = grid[y][x];

      if (saved && saved.room) {
        cell.room = saved.room;
	    cell.tier = saved.tier || 'tier1';
	    cell.manualTier = (
		cell.room === 'spymasters_study' ||
		cell.room === 'altar_of_sacrifice'
);

      } else {
        cell.room = 'Clean';
        cell.tier = 'tier1';
		cell.manualTier = false;

      }

      renderCell(cell);
    }
  }

  // üîÅ WICHTIG: Alles neu berechnen
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      updateTier(x, y);
      updateGuardhouseVariant(x, y);
    }
  }

  recalcAllTiers();

}

window.addEventListener("load", () => {
  if (localStorage.getItem("atziriTempleLayout")) {
    loadLayout();
  }
});

// ------------------------------
// üì§ Export Layout als Text
function exportLayoutAsLink() {
  let raw = "";

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      const roomCode = ROOM_CODE_MAP[cell.room] || "_";
      const tierCode = tierToCode(cell.tier || "tier1");
      raw += roomCode + tierCode;
    }
  }

  const encoded = btoa(raw);
  const url = `${location.origin}${location.pathname}#L=${encoded}`;

  // Direkt ins Clipboard kopieren
  navigator.clipboard.writeText(url).then(() => {
    alert("Layout-URL copied to Clipboard!");
  }).catch(err => {
    console.error("Clipboard couldnt be written:", err);
    alert("Failed to load into clipboard. URL: " + url);
  });
}

function tierToCode(tier) {
  return tier.replace("tier", "");
}

function codeToTier(code) {
  return "tier" + code;
}

// ------------------------------
// Auto-Import aus URL
window.addEventListener("load", () => {
  const hash = location.hash;
  if (hash.startsWith("#L=")) {
    const code = hash.slice(3);
    importLayoutFromCode(code);
  }
});



</script>

</body>
</html>
