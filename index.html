<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=0.2">
<title>Atziris Temple Planner</title>
<style>
  body {
    font-family: sans-serif;
    background: #222;
    color: #eee;
    display: flex;
	flex-direction: column;
    align-items: center; /* Sidebar oben */
    padding-top: 40px;
    min-height: 100vh;
    margin: 0;
  }
  
#editor-title {
  text-align: center;
  color: #fff;
  font-size: 28px;
  font-weight: bold;
  margin-bottom: 20px;
  margin-top: 30px;
  font-family: 'Arial', sans-serif;
}
 
#editor-container {
  display: flex;
  gap: 20px;
  justify-content: center;
  align-items: flex-start;
  margin-top: 20px;
}



/* Grid */
#grid-container { display: flex; justify-content: center; }

#grid {
  display: grid;
  grid-template-columns: repeat(9, 50px);
  grid-template-rows: repeat(9, 50px);
  gap: 12px;
  transform: rotate(45deg);
  margin-top: 120px;
  margin-right: 120px;
  
}

/* ---------------- Grid-Zellen ---------------- */
.cell {
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
	border: 1px solid #333;
    align-items: center;
	line-height: 1em;
    position: relative;
}

.cell span {
  transform: rotate(-45deg); /* Inhalt gegen Grid-Rotation drehen */
  display: block;
}

.cell-content {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
	color: #000;
	font-weight: bold;
	line-height: 1em;
	
	
}



/* Hover-Effekt fÃ¼r Grid-Zellen */
.cell:hover {
  transform: scale(1.05);        /* leichtes VergrÃ¶ÃŸern */
  border-color: #fff;            /* weiÃŸe Umrandung */
  box-shadow: 0 0 10px rgba(255,255,255,0.5); /* leichter Glow */
  transition: transform 0.1s, border-color 0.1s, box-shadow 0.1s;
}

.cell span { transform: rotate(-45deg); }

/* Sidebar */
#sidebar {
  width: 420px;
  padding: 20px;
  background: #181818;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* Aktueller Raum */
#current-room-display {
  text-align: center;
  font-weight: bold;
  font-size: 16px;
}

/* Palette */
#palette-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
}


/* Palette Buttons */
.room-palette-item {
  width: 100px;
  height: 60px;
  border: 1px solid #555;
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: flex-end;
  text-align: center;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  line-height: 1.1;
  color: #fff;
  padding: 2px;
  overflow-wrap: break-word;
  word-break: break-word;
  transition: transform 0.15s, border-color 0.15s, box-shadow 0.15s;
}

.room-palette-item:hover {
  border: 2px solid #00ff00; 
  box-shadow: 0 0 12px #00ff00; /* sanfter Glow */
  transform: scale(1.08);       /* leicht grÃ¶ÃŸer */
}


/* Effekte-Anzeige */
#effects-display {
  border: 1px solid #888;
  padding: 10px;
  min-height: 200px;
  background-color: #222;
  color: #fff;
  font-size: 12px;
  overflow-y: auto;
}

#big-a {
  position: absolute;
  font-size: 60px;
  font-weight: bold;
  color: red;
  pointer-events: none;
  transform: translate(-50%, -50%); /* Zentrum des A */
}

.no-power {
  filter: grayscale(100%);
  opacity: 0.5;
}

.generator-edge {
  position: relative;
  z-index: 1;
}

.generator-edge::before {
  content: "";
  position: absolute;
  inset: -2px;
  border-radius: 4px;
  background: linear-gradient(
    90deg,
    transparent 0%,
    rgba(143, 202, 242, 0.0) 20%,
    rgba(143, 202, 242, 1.2) 50%,
    rgba(143, 202, 242, 0.0) 80%,
    transparent 100%
  );
  background-size: 300% 300%;
  animation: energyRun 2.2s linear infinite;
  pointer-events: none;
  mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  mask-composite: exclude;
  -webkit-mask-composite: xor;
  padding: 3px;
}

@keyframes energyRun {
  from { background-position: 0% 50%; }
  to   { background-position: 300% 50%; }
}

/* Palette links, Buttons rechts */
#palette-and-buttons {
  display: flex;
  align-items: flex-start;
  gap: 14px;
}

 /* Button-Spalte */
#palette-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* Buttons wie echte Buttons */
#palette-buttons button {
  padding: 10px 14px;
  background: #2b2b2b;
  color: #fff;
  border: 1px solid #555;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  transition: background 0.15s, box-shadow 0.15s, transform 0.1s;
}

#palette-buttons button:hover {
  background: #3a3a3a;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

#palette-buttons button:active {
  transform: translateY(1px);
}


/* Button-Spalte */
#palette-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#palette-wrapper {
  display: flex;
  flex-direction: column;
  gap: 10px;
}



.room-palette-item.active {
  border: 2px solid #00ff00;   /* leuchtendes GrÃ¼n */
  box-shadow: 0 0 8px #00ff00; /* Glow-Effekt */
  transform: scale(1.05);      /* leicht vergrÃ¶ÃŸern */
}

/* Upgrade Tooltip States */
.upgrade-ok {
  color: #4caf50; /* grÃ¼n */
  font-weight: 600;
}

.upgrade-missing {
  color: #aaa;
}

.upgrade-title {
  margin-top: 6px;
  font-weight: bold;
  font-size: 12px;
}

.cell::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 70px;
  left: 50%;
  transform: translateX(-50%) rotate(-45deg);
  background: #111;
  color: #fff;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 11px;
  line-height: 1.3;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  z-index: 100;
  box-shadow: 0 0 10px rgba(0,0,0,0.8);
}

.cell:hover::after {
  opacity: 0;
}

#room-tooltip {
  position: fixed;
  background: #111;
  border: 1px solid #555;
  border-radius: 8px;
  padding: 10px 12px;
  font-size: 12px;
  color: #fff;
  pointer-events: none;
  z-index: 1000;
  max-width: 260px;
  box-shadow: 0 0 14px rgba(0,0,0,0.9);
  opacity: 0;
  transition: opacity 0.12s ease;
  
}

#room-tooltip strong {
  font-size: 13px;
}

#room-tooltip .upgrade-ok {
  color: #4caf50;
  font-weight: 600;
}

#room-tooltip .upgrade-missing {
  color: #aaa;
}

#room-tooltip .upgrade-title {
  margin-top: 6px;
  font-weight: bold;
  font-size: 12px;
  color: #fff;
}

.room-palette-item {
  display: flex;
  flex-direction: column; /* Stackt Name und Buttons vertikal */
  align-items: flex-end;    /* Zentriert alles horizontal */
  justify-content: center; 
  padding: 4px;
  text-align: center;
  position: relative;
}




/* ----------------------------- */
/* BrÃ¼cken */
.bridge {
  position: absolute;
  background-color: #00ff00;
  display: none; /* standardmÃ¤ÃŸig unsichtbar */
  z-index: 1;
  border-radius: 2px;
  opacity: 0;
}

/* Aktivierte BrÃ¼cken */
.bridge.active {
  opacity: 1;
  display: block;
}

/* Richtung Up */
.bridge.up {
  width: 6px;
  height: 12px; /* halbe Gap-HÃ¶he */
  top: -12px;
  left: 50%;
  transform: translateX(-50%);
}

/* Richtung Down */
.bridge.down {
  width: 6px;
  height: 12px;
  bottom: -12px;
  left: 50%;
  transform: translateX(-50%);
}

/* Richtung Left */
.bridge.left {
  width: 12px; /* halbe Gap-Breite */
  height: 6px;
  left: -12px;
  top: 50%;
  transform: translateY(-50%);
}

/* Richtung Right */
.bridge.right {
  width: 12px;
  height: 6px;
  right: -12px;
  top: 50%;
  transform: translateY(-50%);
}

.mode-switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
  margin-right: 10px;
}

.mode-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #555;
  transition: 0.4s;
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: #fff;
  transition: 0.4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

/* -------------------- Info Box Styling -------------------- */
#info-box-container {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#toggle-info-btn {
  background: #2b2b2b;
  color: #fff;
  border: 1px solid #555;
  border-radius: 6px;
  padding: 6px 12px;
  font-size: 13px;
  cursor: pointer;
  font-weight: 600;
  margin-bottom: 4px;
}

#toggle-info-btn:hover {
  background: #3a3a3a;
}

#info-box {
  background: #181818;
  color: #eee;
  border: 1px solid #555;
  border-radius: 6px;
  padding: 10px;
  font-size: 12px;
  line-height: 1.4;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
  opacity: 0;
}

#info-box.expanded {
  max-height: 800px; /* genug Platz fÃ¼r Inhalt */
  max-width: 400px;
  overflow-wrap: break-word;
  opacity: 1;
}


.room-palette-item {
  display: flex;
  flex-direction: column;
  justify-content: flex-end; /* â¬… Text nach unten */
  align-items: center;
  position: relative;
}

.room-palette-item > div {
  color: white;              /* â¬… Text weiÃŸ */
  font-size: 14px;
  text-align: center;
  padding-bottom: 1px;       /* â¬… Abstand zum unteren Rand */
  pointer-events: none;
}


	<!--CSS -->
 
</style>
</head>
<body>

 <h1 id="editor-title">PoE2 Atziri's Temple Planner - Tetriszocker</h1>
 
 <div id="mode-switch-container" style="text-align:center; margin-bottom:10px;">
  <label class="mode-switch">
    <input type="checkbox" id="modeToggle">
    <span class="slider"></span>
  </label>
  <span id="mode-info" title="Ingame Logic active">
    Ingame Logic used
  </span>
</div>

 
 <div id="editor-container">
  <!-- Grid links -->
  <div id="grid-container">
    <div id="grid"></div>
	
  </div>
  


  <!-- Sidebar rechts -->
  <div id="sidebar">
  
  <div id="info-box-container">
  <button id="toggle-info-btn">â„¹ Info & Temple Layouts </button>
  <div id="info-box" class="collapsed">
    <p>
		KNOWN ISSUES: Ingame you cannot place any Spymaster after using a Commander in a chain (not sure if this is a bug ingame or intended); 
<BR>
<BR>		
      Welcome to the Atziri Temple Planner!<br>
      - You can switch the placement mode via the switch above the grid.<br>
      - The ingame mode uses the ingame placement ruleset.<br>
      - You can click a tile and it shows you where you can place it via a green box.<br>
      - Manuel mode allows you to ignore the placement rules and just follows the ingame upgrade rules. <br>
	  - If you cannot place anything, reset your grid so the first Path gets autoplaced. <br>
	  - Medallion can be used on any tile to increase its Tier. This will currently brick the upgradelogic for some tiles and should only be used for your overview. <br>
	  - First time coding something so no garantuees that this is 100% correct. If you find a bug, please use this reddit thread to post it or give your feedback. <br>
	  - Most importantly: Have fun and stay sane exiles!<br>
	<Br> 	
	Some good Temple Layouts that MilkyBk_ , I and the community made: 
	<a href=https://tetriszocker.github.io/atziri-temple-editor/#L=QTFHN1MzRzdBMUc3UzNHN0ExRzdfMUoxXzFBMUczQzJHM0c3UzNfMV8xQzJHM0c3QTJBMVMzRzdMMkEyRzNHN1MzTDJHM0c3QTFUMVMzRzdBMV8xVDFDMkExRzdSM0c3XzFSMlQxTDNHMkc3UzNaM0EyTDJfMVQxUjJDMlMzRzdUM18xVDFfMUwyQTJHM0c3QTJMMl8xUjJQMVIyVDFMMkEy target="_blank" rel="noopener noreferrer"> Temple Layout 1 </a> <Br>
	<a href=https://tetriszocker.github.io/atziri-temple-editor/#L=QTFHN1MzRzdBMUc3UzNHN0ExRzdHN0ExRzdTM0c3QTFHN0c3UzNTM0EyRzNDMl8xXzFTM1MzRzdHN0wyRzJHM18xSjFHN0c3QTFBMVQxQzJBMV8xXzFBMkExRzdHN1IyRzNHN1MzRzdMMkc3UzNTM18xQTJUMUwyQTJUM1MzRzdHN0EyTDFSMl8xUjNaM0c3QTJMMlQxUjJQMV8xVDFMMkEy target="_blank" rel="noopener noreferrer"> Temple Layout 2 </a> <Br>
	<a href=https://tetriszocker.github.io/atziri-temple-editor/#L=QTFHN1MzRzdBMUc3UzNHN0EyRzdHN1MzRzdBMkwyVDNaM0wyUzNBMV8xSjFfMUczQTJSM1QxRzdHN18xXzFHMkMyTDFBMkc3QTFTM1QxUjJDMl8xTDJBMlMzRzdHN0wyQTJHM1IyVDFHN0c3UzNBMl8xQTJHN1MzXzFTM0ExRzdMMlQxTDJfMUc3QTFHN0c3QTJMMlQxUjJQMUwxQTJHN1Mz target="_blank" rel="noopener noreferrer"> Temple Layout 3 </a> <Br>
	<a href=https://tetriszocker.github.io/atziri-temple-editor/#L=QTFHN1MzRzdBMUc3UzNHN0ExRzdHN0ExRzdTM0c3XzFfMUc3UzNTM0EyRzdTM0ExXzFKMVMzRzdHN0wyUjJHN0c3UzNfMUc3QTFBMVQxVDFBMUc3RzdBMkExRzdHN1IyTDJfMVMzRzdMMkc3UzNTM18xQTJUMUwyQTJUM1MzRzdHN0EyQjFSMl8xUjNaM0c3QTJMMlQxUjJQMV8xVDFMMkEy target="_blank" rel="noopener noreferrer"> Temple Layout 4 </a> <Br>
	<a href=https://www.twitch.tv/milkybk_ target="_blank" rel="noopener noreferrer"> Milkys Stream </a> <Br>
	

    </p>
  </div>
</div>
    <!-- Aktueller Raum -->
    <div id="current-room-display"></div>

	<div id="palette-and-buttons">

  <!-- PALETTE -->
  <div id="palette-wrapper">

   
    <!-- Deine bestehenden Raum-KÃ¤stchen -->
    <div id="palette-container"></div>

  </div>

  <!-- FUNKTIONSBUTTONS -->
  <div id="palette-buttons">
    <button id="reset-button">Reset Grid</button>
    <button id="save-button">ðŸ’¾ Save Layout</button>
    <button id="load-button">ðŸ“‚ Load Layout</button>
    <button id="export-button">ðŸ“¤ Export as URL</button>
	

  </div>

</div>

    <!-- Effekte-Anzeige -->
    <div id="effects-display">
      <h3>Room Effects</h3>
      <div id="sidebar-content"></div>
    </div>
  </div>
  
  <div id="big-a">A</div>
  
</div>

<div id="room-tooltip"></div>
<script>
    // ------------------------------
// Mapping fÃ¼r Anzeige der Tier-Namen in Sidebar und Tooltip
const TIER_DISPLAY_NAME = {
  tier1: 'Tier 1',
  tier2: 'Tier 2',
  tier3: 'Tier 3',
  tier4: 'Transcendent 2',
  tier5: 'Transcendent 3',
  tier6: 'Legion 2',
  tier7: 'Legion 3'
};


function nextTier(tier) {
  const n = parseInt(tier.replace('tier',''));
  if (n >= 7) return null; // maximale Tierstufe erreicht
  return 'tier' + (n + 1);
}
// 1ï¸âƒ£ ROOM_DATA (gekÃ¼rzt als Beispiel, alle 59 RÃ¤ume kÃ¶nnen hier eingefÃ¼gt werden)
  // ------------------------------
  const ROOM_DATA = {
  // -------------------------
  // 1. Path
path: {
    id: 'path',
    name: 'Path',
    color: '#cccccc',
    tooltip: 'A simple path tile with no effects.',
    variants: {
      tier1: { effects: [] }
    },
    upgrades: {},
    //upgradeInfoFunction: (cellObj) => "No upgrades available"
},
  // -------------------------
  // 2. Garrison Group
  guardhouse: {
    id: 'guardhouse',
    name: 'Garrison',
    color: '#f28c8c',
    tooltip: 'Increased number of Monster Packs',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconGarrison.webp' ,
	transcendentIcon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconTranscendentBarracks.webp',
    legionIcon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconViperLegionBarracks.webp',
    variants: {
      tier1: { effects: ['10% increased number of Monster Packs'] },
      tier2: { effects: ['15% increased number of Monster Packs'] }, // Barracks
      tier3: { effects: ['20% increased number of Monster Packs'] },
	  tier4: { effects: ['30% increased number of Magic Monsters'] },
	  tier5: { effects: ['60% increased number of Magic Monsters'] },
	  tier6: { effects: ['30% increased number of Rare Monsters '] },
	  tier7: { effects: ['60% increased number of Rare Monsters '] },		 
    },
    upgrades: {
      tier2: { type: 'adjacent', rooms: ['commanders_chamber','armoury'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['commanders_chamber','armoury'], requireAll: true },
	  
	  tier4: { type: 'adjacent', rooms: ['synthflesh_lab'], count: 1 },
	  tier5: { type: 'complex', requiredAdjacent: ['synthflesh_lab'], optionalAdjacent: ['armoury','commanders_chamber'], },
	 	  
	  tier6: { type: 'adjacent', rooms: ['spymasters_study'], count: 1 },
	  tier7: { type: 'complex', requiredAdjacent: ['spymasters_study'], optionalAdjacent: ['armoury','commanders_chamber'], },
    }
  },
  // -------------------------
  // 3. Commander Group
  commanders_chamber: {
    id: 'commanders_chamber',
    name: "Commander",
    color: '#f5a36f',
    tooltip: 'Effectiveness of Rare monsters',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconCommander.webp' ,
    variants: {
      tier1: { effects: ['Rare Monsters have 15% increased effectiveness'] },
      tier2: { effects: ['Rare Monsters have 30% increased effectiveness'] },
      tier3: { effects: ['Rare Monsters have 60% increased effectiveness'] }
    },
    upgrades: {
      tier2: { type: 'adjacent', rooms: ['guardhouse',], count: 2 },
      tier3: { type: 'adjacent', rooms: ['guardhouse',], count: 3 }
    }
  },
  // -------------------------
  // 4. Armoury Group
  armoury: {
    id: 'armoury',
    name: 'Armoury',
    color: '#f5d36f',
    tooltip: 'Effectiveness of humanoid monsters',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconArmoury.webp', 
    variants: {
      tier1: { effects: ['Humanoid Monsters have 15% increased effectiveness'] },
      tier2: { effects: ['Humanoid Monsters have 30% increased effectiveness'] },
      tier3: { effects: ['Humanoid Monsters have 60% increased effectiveness'] }
    },
    upgrades: {
      tier2: { type: 'adjacent', rooms: ['bronzeworks', 'chamber_of_souls'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['bronzeworks', 'chamber_of_souls'], requireAll: true }
    }
  },
  // -------------------------
  // 5. Smithy Group
bronzeworks: {
    id: 'bronzeworks',
    name: 'Smithy',
    color: '#fc8c6f',
    tooltip: 'Increases chest item rarity',
	icon: ' https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconSmithy.webp',
    variants: {
      tier1: { effects: ['Chests have 15% more item rarity'] },
      tier2: { effects: ['Chests have 30% more item rarity'] },
      tier3: { effects: ['Chests have 60% more item rarity'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['workshop', 'dynamo'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['workshop', 'dynamo'], count: 2 },
	}

},

  // -------------------------
  // 6. Generator Group
  dynamo: {
  id: 'dynamo',
  name: 'Generator',
  color: '#8fcaf2',
  tooltip: 'Required for Smithy, Synth Lab, Transc Barracks and 2x for Workshop Upgrades',
  icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconGenerator.webp', 
  providesEnergy: true,
  energyRangeByTier: {
    tier1: 3,
    tier2: 4,
    tier3: 5
  },
  variants: {
    tier1: { effects: ['Construct Monsters have 15% increased effectiveness'] },
    tier2: { effects: ['Construct Monsters have 30% increased effectiveness'] },
    tier3: { effects: ['Construct Monsters have 60% increased effectiveness'] }
  },
  upgrades: {
    tier2: { type: 'adjacent', rooms: ['thaumaturges_laboratory', 'altar_of_sacrifice'], count: 1 },
    tier3: { type: 'complex', requiredAdjacent: ['thaumaturges_laboratory', 'altar_of_sacrifice'], }
  }
},

  // -------------------------
  // 7. Spymaster Group
spymasters_study: {
    id: 'spymasters_study',
    name: "Spymaster",
    color: '#6fcf6f',
    tooltip: 'Increases Temple Mod effects. Upgrades by assassinating other Spymasters',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconViperSpymaster.webp', 
    variants: {
      tier1: { effects: ['8% increased effect of Garrisons, Commanders, Armouries, Smithies, and Legion Barracks'] },
      tier2: { effects: ['15% increased effect of Garrisons, Commanders, Armouries, Smithies, and Legion Barracks'] },
      tier3: { effects: ['30% increased effect of Garrisons, Commanders, Armouries, Smithies, and Legion Barracks'] }
    },
    upgrades: {},
    upgradeInfoFunction: (cellObj) => "Spymaster upgrades by assassinating other Spymasters. For the editor, place the Spymaster then click on the desired Tier"
},
  // -------------------------
  // 9. Synthflesh Lab Group
  synthflesh_lab: {
    id: 'synthflesh_lab',
    name: 'Synth Lab',
    color: '#cf6fcf',
    tooltip: 'Increases exp gain',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconSynthflesh.webp', 
    variants: {
      tier1: { effects: ['10% increased exp'] },
      tier2: { effects: ['20% increased exp'] },
      tier3: { effects: ['40% increased exp'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['surgeons_ward', 'dynamo'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['surgeons_ward', 'dynamo'], count: 2 }
	 
    }
  },
  // -------------------------
  // 10. Flesh Surgeon Group
  surgeons_ward: {
    id: 'surgeons_ward',
    name: "Flesh Surgeon",
    color: '#cf8c6f',
    tooltip: 'Effectiveness of unique Monsters',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconFleshSurgeon.webp',
    variants: {
      tier1: { effects: ['10% Unique Monster Effectiveness'] },
      tier2: { effects: ['20% Unique Monster Effectiveness'] },
      tier3: { effects: ['40% Unique Monster Effectiveness'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['synthflesh_lab'], minTier: 0, count: 1 },
    tier3: { type: 'adjacent', rooms: ['synthflesh_lab'], minTier: 1, count: 1 }
	}
  },
  // -------------------------
  // 11. Golem Works Group
  workshop: {
    id: 'workshop',
    name: 'Golem Works',
    color: '#8cf2cf',
	tooltip: 'increased effect of Temple Mods from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconGolemWorks.webp', 
    variants: {
      tier1: { effects: ['8% increased effect from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs'] },
      tier2: { effects: ['15% increased effect from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs'] },
      tier3: { effects: ['30% increased effect from Generators, Synthflesh Labs, Flesh Surgeons, Transcendent Barracks, and Alchemy Labs'] }
    },
    upgrades: {  
	tier2: { type: 'adjacent', rooms: ['dynamo'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['dynamo'], count: 2 },
			  }
   },
  // -------------------------
  // 12. Alchemy Lab Group
  chamber_of_souls: {
    id: 'chamber_of_souls',
    name: 'Alchemy Lab',
    color: '#f2cf6f',
    tooltip: 'Item rarity on Monsters',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconAlchemyLab.webp', 
    variants: {
      tier1: { effects: ['15% increased item rarity'] },
      tier2: { effects: ['30% increased item rarity'] },
      tier3: { effects: ['60% increased item rarity'] }
    },
    upgrades: {
	tier2: { type: 'adjacent', rooms: ['thaumaturges_laboratory'], count: 1 },
    tier3: { type: 'adjacent', rooms: ['thaumaturges_laboratory'], count: 2 }
	}
  },
  // -------------------------
  // 13. Thaumaturge Group
  thaumaturges_laboratory: {
    id: 'thaumaturges_laboratory',
    name: "Thaumaturge's",
    color: '#6ff2cf',
    tooltip: 'Increased effect of Temple Mods from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconThaumaturge.webp' ,
    variants: {
      tier1: { effects: ['8% increased effect from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers'] },
      tier2: { effects: ['15% increased effect from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers'] },
      tier3: { effects: ['30% increased effect from Corruption Chambers, Treasure Vaults, and Sacrificial Chambers'] }
    },
    upgrades: {
	  tier2: { type: 'adjacent', rooms: ['altar_of_sacrifice'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['altar_of_sacrifice'], count: 2 }
	}
  },
  // -------------------------
  // 14. Corruption Chamber Group
  crimson_hall: {
    id: 'crimson_hall',
    name: 'Corruption Chamber',
    color: '#f26fcf',
    tooltip: 'Rare Monsters have a 15% chance to have an additional Modifier',
	icon:'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconCorruption.webp', 
    variants: {
      tier1: { effects: ['Rare Monsters have a 15% chance to have an additional Modifier'] },
      tier2: { effects: ['Rare Monsters have a 30% chance to have an additional Modifier'] },
      tier3: { effects: ['Rare Monsters have a 60% chance to have an additional Modifier'] }
    },
    upgrades: {
	  tier2: { type: 'adjacent', rooms: ['altar_of_sacrifice', 'thaumaturges_laboratory'], count: 1 },
      tier3: { type: 'adjacent', rooms: ['altar_of_sacrifice', 'thaumaturges_laboratory'], count: 2 }}
  },

  // -------------------------
  // 15. Sacrificial Chamber Group
  altar_of_sacrifice: {
    id: 'altar_of_sacrifice',
    name: 'Sacrifical Chamber',
	color: '#6f6f6f',
    tooltip: 'More rare Chests',
	icon:'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconSacrificialChamber.webp',
    variants: {
      tier1: { effects: ['15% increased amount of Rare Chests'] },
      tier2: { effects: ['30% increased amount of Rare Chests'] },
      tier3: { effects: ['60% increased amount of Rare Chests. '] }
    },
    upgrades: {},
	upgradeInfoFunction: (cellObj) => "Upgrades by sacrificing another room."
  },
  // -------------------------
  // 16. Reward Rooms (Joker)
  joker: {
    id: 'joker',
    name: 'Reward Room',
	color: '#ffffff',
	icon: 'https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconRewardCurrency.webp',
    tooltip: 'Special reward room. No effect.',
    variants: {
      tier1: { effects: [] }
    },
    upgrades: {},
	upgradeInfoFunction: (cellObj) => "No upgrades available"
  },
     // 17. Clean Tile 
  Clean: {
    id: 'Clean',
    name: 'Clean Tile',
    color: '#111',
    tooltip: '',
	showTooltip: false,
    variants: {
      tier1: { effects: [] }
    },
    upgrades: {},
	upgradeInfoFunction: (cellObj) => "No upgrades available"
  },
  
  sealed_vault: {
  id: 'sealed_vault',
  name: "Sealed Vault",
  color: "#7a6c3a", // gold-braun, kannst du anpassen
  icon: "https://cdn.poe2db.tw/image/Art/Textures/Interface/2D/2DArt/UIImages/InGame/Incursion2/RoomIcons/IconVault.webp", // optional, falls du Icons nutzt
  tooltip: "Increases item rarity by 25%.",
  variants: {
      tier1: { effects: ['25% increased rarity of items dropped by Monsters'] },
  upgrades: {}, // â— bewusst leer â†’ keine Upgrades
  upgradeInfoFunction: (cellObj) => "No upgrades available"
}
}
   
};
// Liste gÃ¼ltiger Zellen im Logic Mode
let validPlacementCells = [];


// ==============================
// Effekt-Gruppierung (SCHRITT 3)
// ==============================

const EFFECT_GROUPS = {
  LOOT: [
    'rarity',
    'rarity of items dropped',
	'Monster Effectiveness',
    'Chests',
    'Rare Chests'
  ],
  MONSTER: [
    'Monster Packs',
    'Magic Monsters',
    'Rare Monsters',
    'additional Modifier'
  ]
};
  
  const META_TARGETS = {
  spymasters_study: [
    { room: 'guardhouse', tiers: [1,2,3] }, // normale Garrisons
    { room: 'guardhouse', tiers: [6,7] },    // Legion Barracks
	{ room: 'commanders_chamber', tiers: [1,2,3] },
	{ room: 'armoury', tiers: [1,2,3] },
	{ room: 'bronzeworks', tiers: [1,2,3] }
    // Transcendent Barracks T4-5 wird weggelassen
  ],
  workshop: [
    { room: 'dynamo', tiers: [1,2,3] },
    { room: 'synthflesh_lab', tiers: [1,2,3] },
    { room: 'surgeons_ward', tiers: [1,2,3] },
	{ room: 'chamber_of_souls', tiers: [1,2,3] },
	{ room: 'guardhouse', tiers: [4,5] }
  ],
  thaumaturges_laboratory: [
    { room: 'crimson_hall', tiers: [1,2,3] },
    { room: 'sealed_vault', tiers: [1] },
    { room: 'altar_of_sacrifice', tiers: [1,2,3] }
  ]

};
// ------------------------------
// Raum â†” Code Mapping
const ROOM_CODE_MAP = {
  path: "P",
  guardhouse: "G",
  commanders_chamber: "C",
  armoury: "A",
  bronzeworks: "B",
  dynamo: "D",
  spymasters_study: "S",
  synthflesh_lab: "Y",
  surgeons_ward: "F",
  workshop: "W",
  chamber_of_souls: "L",
  thaumaturges_laboratory: "T",
  crimson_hall: "R",
  altar_of_sacrifice: "Z",
  joker: "J",
  sealed_vault: "SV",
  Clean: "_"
};

const ROOM_CODE_MAP_REVERSE = Object.fromEntries(
  Object.entries(ROOM_CODE_MAP).map(([room, code]) => [code, room])
);

const CODE_ROOM_MAP = Object.fromEntries(
  Object.entries(ROOM_CODE_MAP).map(([k, v]) => [v, k])
);

const GENERATOR_ROOMS = ['dynamo'];
 // ------------------------------
// 2. Globale Variable fÃ¼r aktuell ausgewÃ¤hlten Raum
let current = ROOM_DATA['path']; 

const sidebarContent = document.getElementById("sidebar-content");
const tooltipEl = document.getElementById("room-tooltip");

let selectedCell = null; // speichert die aktuell ausgewÃ¤hlte Zelle auf dem Grid

let placementMode = 'logic'; // 'logic' = automatische VorschlÃ¤ge, 'manual' = alles erlaubt
// ------------------------------
// 3. Aktueller Raum anzeigen
const currentRoomEl = document.getElementById('current-room-display');
function updateCurrentRoomDisplay() {
  currentRoomEl.innerText = current.name;
  currentRoomEl.title = current.tooltip;
}
updateCurrentRoomDisplay();
// ------------------------------
// 4. Palette erstellen
// ------------------------------
// 4. Palette erstellen
const paletteContainer = document.getElementById('palette-container');

// ðŸ”¹ Zuerst den Medallion-Raum erstellen und hinzufÃ¼gen
const medallionPaletteItem = document.createElement("div");
medallionPaletteItem.classList.add("room-palette-item");

medallionPaletteItem.textContent = "Medallion +1 Tier";
medallionPaletteItem.title = "Increase the Tier by 1";
medallionPaletteItem.style.backgroundColor = "#FFD700"; // z.B. gold
medallionPaletteItem.style.border = "3px solid #7c5726"; // Oranger Rand
medallionPaletteItem.style.borderRadius = "6px"; // optional: abgerundete Ecken

// Klick-Event fÃ¼r Medallion
medallionPaletteItem.addEventListener("click", () => {
    // Medallion als aktuell ausgewÃ¤hlten Raum setzen
    current = { id: 'medallion', name: 'Medallion' };

    // Alle aktiven Markierungen entfernen
    document.querySelectorAll('.room-palette-item').forEach(item => item.classList.remove('active'));

    // Medallion als aktiv markieren
    medallionPaletteItem.classList.add('active');

    // Anzeige aktualisieren
    updateCurrentRoomDisplay();

    // Logic-Modus: nur gÃ¼ltige Zellen markieren
    if (placementMode === 'logic') {
        markValidCellsForCurrent();
    }
});

// Medallion-Element der Palette hinzufÃ¼gen
paletteContainer.appendChild(medallionPaletteItem);

// ðŸ”¹ Jetzt die normalen RÃ¤ume aus ROOM_DATA hinzufÃ¼gen
for (const roomId in ROOM_DATA) {
    const room = ROOM_DATA[roomId];

    // Haupt-Element fÃ¼r den Raum erstellen
   const el = document.createElement('div');
	el.classList.add('room-palette-item');

	if (room.icon) {
    el.style.backgroundImage = `url('${room.icon}')`;
    el.style.backgroundSize = "contain";
    el.style.backgroundRepeat = "no-repeat";
    el.style.backgroundPosition = "center";
	} else {
    el.style.backgroundColor = room.color; // Fallback, falls kein Icon
	}


    // Raumname hinzufÃ¼gen
    const roomLabel = document.createElement('div');
    roomLabel.innerText = room.name;
    roomLabel.style.pointerEvents = 'none'; // Label klickbar nicht
    el.appendChild(roomLabel);

    // Daten-Attribute setzen
    el.dataset.roomId = roomId;
    el.title = room.tooltip;

    // Klick-Event fÃ¼r normalen Raum
    el.onclick = () => {
        current = ROOM_DATA[roomId];

        // Anzeige aktualisieren
        updateCurrentRoomDisplay();
        updateGeneratorRanges();

        // Alle aktiven Markierungen entfernen
        document.querySelectorAll('.room-palette-item').forEach(item => item.classList.remove('active'));

        // Diesen Raum als aktiv markieren
        el.classList.add('active');

        // Logic-Modus: nur gÃ¼ltige Zellen markieren
        if (placementMode === 'logic') {
            markValidCellsForCurrent();
        }
    };

    

    // Raum-Element der Palette hinzufÃ¼gen
    paletteContainer.appendChild(el);
}

// ------------------------------
// Hilfsfunktion: markiert gÃ¼ltige Zellen im Logic-Modus
function markValidCellsForCurrent() {
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cellObj = grid[y][x];

            if (isValidPlacement(cellObj)) {
                cellObj.el.style.outline = '2px solid #2a940f'; // grÃ¼n
                cellObj.el.style.cursor = 'pointer';
            } else {
                cellObj.el.style.outline = '';
                cellObj.el.style.cursor = 'not-allowed';
            }
        }
    }
}


// ------------------------------
// 5. Grid erstellen
const gridEl = document.getElementById("grid");
const gridSize = 9;
let grid = [];

for (let y = 0; y < gridSize; y++) {
  let row = [];
  for (let x = 0; x < gridSize; x++) {
    const cell = document.createElement("div");
cell.classList.add("cell");

const content = document.createElement("div");
content.classList.add("cell-content");
cell.appendChild(content);

    cell.dataset.x = x;
    cell.dataset.y = y;

    const bridges = {
  up: document.createElement("div"),
  down: document.createElement("div"),
  left: document.createElement("div"),
  right: document.createElement("div"),
};

bridges.up.className = "bridge up";
bridges.down.className = "bridge down";
bridges.left.className = "bridge left";
bridges.right.className = "bridge right";

Object.values(bridges).forEach(b => {
  cell.appendChild(b);
});


const cellObj = {
  el: cell,
  room: 'Clean',
  tier: 'tier1',
  manualTier: false,
  x,
  y,
  bridges
};


    // Zelle ins Grid
    gridEl.appendChild(cell);
    row.push(cellObj);

    // Tooltip Event-Listener
    cell.addEventListener("mouseenter", () => {
  const cellObj = grid[y][x];
  const roomData = ROOM_DATA[cellObj.room];
  if (!roomData) return;

  const displayTier = TIER_DISPLAY_NAME[cellObj.tier] || cellObj.tier;
  
  // Anforderungen fÃ¼r das nÃ¤chste Upgrade
const next = nextTier(cellObj.tier);
let upgradeText = "No upgrades available";

// âœ… zuerst prÃ¼fen, ob upgradeInfoFunction existiert
if (roomData.upgradeInfoFunction) {
    upgradeText = roomData.upgradeInfoFunction(cellObj);
} 
// ansonsten bestehende room.upgrades prÃ¼fen
else {
    const next = nextTier(cellObj.tier);
    if (next && roomData.upgrades?.[next]) {
        const upgrade = roomData.upgrades[next];
        if (upgrade.type === "adjacent") {
            upgradeText = `${TIER_DISPLAY_NAME[next]}: Adjacent Rooms required: ${upgrade.rooms.map(id => ROOM_DATA[id]?.name || id).join(", ")} (at least ${upgrade.count})`;
        } else if (upgrade.type === "complex") {
            upgradeText = `${TIER_DISPLAY_NAME[next]}: Requires ${upgrade.requiredAdjacent.map(id => ROOM_DATA[id]?.name || id).join(", ")}, and: ${upgrade.optionalAdjacent.map(id => ROOM_DATA[id]?.name || id).join(", ")}`;
        }
    }
}

  tooltipEl.innerHTML = `
    <strong>${roomData.name}</strong><br>
    Tier: ${displayTier}<br>
    ${upgradeText}
  `;
  tooltipEl.style.opacity = "1";
});

    cell.addEventListener("mousemove", (e) => {
      tooltipEl.style.left = e.clientX + 20 + "px";
      tooltipEl.style.top  = e.clientY - 10 + "px";
    });

    cell.addEventListener("mouseleave", () => {
      tooltipEl.style.opacity = "0";
    });

    // Klick zum Platzieren
    cell.onclick = () => placeRoom(x, y);
  }
  grid.push(row);
}

// ---------------
// Initiale StraÃŸe setzen (unterste Reihe, 5. Spalte)
const startX = 4; // 0-basiert: 5. Spalte
const startY = gridSize - 1; // unterste Reihe
const startCell = grid[startY][startX];
startCell.room = 'path';
startCell.tier = 'tier1';
startCell.manualTier = false;
renderCell(startCell);


const modeToggle = document.getElementById("modeToggle");
const modeInfo = document.getElementById("mode-info");

// globaler Modus
window.manualMode = false; // Standard = Logik-Modus

modeToggle.addEventListener("change", () => {
    if (modeToggle.checked) {
        // Manueller Modus
        window.manualMode = true;
        modeInfo.textContent = "Manuel placement";
        modeInfo.title = "You can freely place rooms";
    } else {
        // Logikmodus
        window.manualMode = false;
        modeInfo.textContent = "Ingame logic used";
        modeInfo.title = "Only allowed placements possible!";
    }
});


  positionBigA();

  window.addEventListener('resize', positionBigA);

function positionBigA() {
  const bigA = document.getElementById('big-a');

  const gridRect = gridEl.getBoundingClientRect();
  const gridSize = 9;
  const cellWidth = gridRect.width / gridSize;
  const cellHeight = gridRect.height / gridSize;

  // Wir wollen es "oben rechts auf der Diagonale" platzieren
  // Das entspricht ungefÃ¤hr etwas oberhalb der Zelle [0][4]
  const diagonalIndex = 3;

  const top = cellHeight * diagonalIndex * 0.6; // etwas oberhalb
  const left = cellWidth * (gridSize - 1 - diagonalIndex) * 1.4; // leicht rechts

  bigA.style.top = `${gridRect.top + top}px`;
  bigA.style.left = `${gridRect.left + left}px`;
}

positionBigA();
window.addEventListener('resize', positionBigA);
// ------------------------------
// Generator-Reichweite nach Tier
function getGeneratorRange(tier) {
  const t = parseInt(tier.replace('tier',''));
  return 2 + t; // Tier1 = 3 Felder, Tier2 = 4, Tier3 = 5
}
// ------------------------------
// 6. Funktion zum Setzen eines Raums in der Zelle
function placeRoom(x, y) {
  if (!current) return;
  
  const cellObj = grid[y][x];
  selectedCell = cellObj;

  // ðŸ”¹ Spezialfall: Medallion
  if (current.id === 'medallion') {
      if (!cellObj.room || cellObj.room === 'Clean') return; // Medallion nur auf bestehenden RÃ¤umen
      const oldTier = cellObj.tier;
      const next = nextTier(oldTier); // vorhandene Funktion nutzen
      if (next) {
          cellObj.tier = next;
          cellObj.manualTier = true; // markiert, dass Tier manuell gesetzt wurde
          renderCell(cellObj);
          updateEffectsSidebar();
      }
      return; // fertig, sonst nichts tun
  }

  // ðŸ”¹ WENN Clean gesetzt wird â†’ kompletter Reset
  if (current.id === 'Clean') {
      cellObj.room = 'Clean';
      cellObj.tier = 'tier1';
      cellObj.manualTier = false;
      renderCell(cellObj);
      highlightValidCells();
      recalcAllTiers();
      updateGeneratorRanges();
      updateEffectsSidebar();
      return;
  }

  // ðŸ”¹ Normaler Raum
  if (placementMode === 'logic' && !isValidPlacement(cellObj)) return;

  cellObj.room = current.id;
  cellObj.blockedConnections = [];
  cellObj.tier = 'tier1';
  cellObj.manualTier = false;

  renderCell(cellObj);
  recalcAllTiers();
  updateGeneratorRanges();
  highlightValidCells();
  markValidCellsForCurrent();
  updateEffectsSidebar();

  
  
}


function highlightValidCells() {
    if (placementMode === 'manual') {
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                grid[y][x].el.style.outline = '';
                grid[y][x].el.style.cursor = 'pointer';
            }   }   }
   }

//Illegale Placements Combos//
const ILLEGAL_PLACEMENT_RULES = [
    {
        type: 'unique',
        room: 'altar_of_sacrifice'
    },
    {
        type: 'maxNeighborCount',
        room: 'thaumaturges_laboratory',
        targetNeighbor: 'crimson_hall',
        limitedNeighbor: 'thaumaturges_laboratory',
        max: 1
    },
		{
        type: 'maxNeighborCount',
        room: 'armoury',
        targetNeighbor: 'guardhouse', 
        limitedNeighbor: 'armoury',
        max: 1
    },
	{
        type: 'maxNeighborCount',
        room: 'armoury',
        targetNeighbor: 'guardhouse', 
        limitedNeighbor: 'synthflesh_lab',
        max: 1
    },
	{
        type: 'maxNeighborCount',
        room: 'spymasters_study',
        targetNeighbor: 'guardhouse',
        limitedNeighbor: 'spymasters_study',
        max: 1
    },
	{
        type: 'maxNeighborCount',
        room: 'spymasters_study',
        targetNeighbor: 'guardhouse',
        limitedNeighbor: 'commanders_chamber',
        max: 1
    },
	{
        type: 'maxNeighborCount',
        room: 'commanders_chamber',
        targetNeighbor: 'guardhouse',
        limitedNeighbor: 'spymasters_study',
        max: 1
    },
	{
        type: 'maxNeighborCount',
        room: 'chamber_of_souls',
        targetNeighbor: 'armoury',
        limitedNeighbor: 'chamber_of_souls',
        max: 1
    },
	{
        type: 'maxNeighborCount',
        room: 'synthflesh_lab',
        targetNeighbor: 'guardhouse',
        limitedNeighbor: 'synthflesh_lab',
        max: 1
    },
	{
        type: 'maxNeighborCount',
        room: 'synthflesh_lab',
        targetNeighbor: 'guardhouse',
        limitedNeighbor: 'armoury',
        max: 1
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'guardhouse'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'commanders_chamber'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'armoury'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'bronzeworks'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'spymasters_study'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'synthflesh_lab'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'surgeons_ward'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'chamber_of_souls'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'thaumaturges_laboratory'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'workshop'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'crimson_hall'
    },
	{
        type: 'requiresAtLeastOneValidConnection',
        room: 'altar_of_sacrifice'
    }
	
	
];


function isRoomAlreadyPlaced(roomId) {
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            if (grid[y][x].room === roomId) {
                return true;
            }
        }
    }
    return false;
}



function checkIllegalPlacementRules(cellObj) {
    const neighbors = getNeighbors(cellObj);
    const blockedConnections = [];

    for (const rule of ILLEGAL_PLACEMENT_RULES) {
        // ðŸ”’ Unique bleibt HARD BLOCK
        if (rule.type === 'unique' && rule.room === current.id) {
            if (isRoomAlreadyPlaced(rule.room)) {
                return { allowed: false, blockedConnections };
            }
        }

        // ðŸš« T - R - T Regel (SOFT)
        if (rule.type === 'maxNeighborCount' && rule.room === current.id) {
            for (const n of neighbors) {
                if (n.room === rule.targetNeighbor) {
                    const theirNeighbors = getNeighbors(n);
                    const count = theirNeighbors.filter(
                        nn => nn.room === rule.limitedNeighbor
                    ).length;

                    if (count >= rule.max) {
                        blockedConnections.push(n);
                    }
                }
            }
        }

        // âœ… Mindestens eine mÃ¶gliche Verbindung nÃ¶tig (nur Nachbar des Nachbarn)
        if (rule.type === 'requiresAtLeastOneValidConnection' && rule.room === current.id) {
    const hasValidNeighbor = neighbors.some(n =>
        areRoomsAdjacentAllowed(current.id, n.room)
    );

    if (!hasValidNeighbor) {
        return { allowed: false, blockedConnections };
    }
}

    }

    return {
        allowed: true,
        blockedConnections
    };
}

function isValidPlacement(cellObj) {
    if (window.manualMode) return true; // Manuell-Modus: alles erlaubt

    const neighbors = getNeighbors(cellObj);
    const ruleResult = checkIllegalPlacementRules(cellObj);

    if (!ruleResult.allowed) return false;

    // â— Blockierte Verbindungen merken
    cellObj.blockedConnections = ruleResult.blockedConnections;

    // Joker kann Ã¼berall platziert werden
    if (current.id === 'joker') return true;

    // Clean kann nur gesetzt werden, wenn kein Nachbar auf diese Zelle angewiesen ist
    if (current.id === 'Clean') return canCleanCell(cellObj);

    // Bereits belegte Zellen ausschlieÃŸen
    if (cellObj.room && cellObj.room !== 'Clean') return false;

    // Mapping erlaubter Nachbarn pro Raum
    const allowedNeighborMap = {
        'path': ['path'],
        'guardhouse': ['path', 'commanders_chamber', 'armoury', 'synthflesh_lab', 'spymasters_study'],
        'commanders_chamber': ['path', 'guardhouse'],
        'armoury': ['path', 'bronzeworks', 'chamber_of_souls', 'guardhouse'],
        'bronzeworks': ['path', 'workshop', 'armoury'],
        'dynamo': ['path'],
        'spymasters_study': ['path', 'guardhouse'],
        'synthflesh_lab': ['path', 'surgeons_ward', 'guardhouse'],
        'surgeons_ward': ['path', 'synthflesh_lab'],
        'chamber_of_souls': ['path', 'thaumaturges_laboratory', 'armoury'],
        'thaumaturges_laboratory': ['path', 'altar_of_sacrifice', 'chamber_of_souls', 'crimson_hall'],
        'workshop': ['path', 'bronzeworks'],
        'crimson_hall': ['path', 'altar_of_sacrifice', 'thaumaturges_laboratory'],
        'altar_of_sacrifice': ['path', 'dynamo', 'crimson_hall', 'thaumaturges_laboratory'],
        'sealed_vault': ['path']
    };

    const allowed = allowedNeighborMap[current.id] || [];

    // PrÃ¼fe normale erlaubte Nachbarn (ohne blockierte)
    const canPlace = neighbors.some(n => allowed.includes(n.room) && !cellObj.blockedConnections.includes(n));
    if (!canPlace) return false;

    // PrÃ¼fe fÃ¼r blockierte Nachbarn, ob sie noch alternative Nachbarn haben
    if (cellObj.blockedConnections.length) {
        const secondLevelOk = neighbors.some(n => {
            if (!allowed.includes(n.room)) return false;
            if (cellObj.blockedConnections.includes(n)) {
                const nNeighbors = getNeighbors(n).filter(nn => nn !== cellObj);
                return nNeighbors.some(nn => allowed.includes(nn.room));
            }
            return true;
        });
        if (!secondLevelOk) return false;
    }

    return true;
}

// Hilfsfunktion: Nachbarn der Zelle abrufen
function getNeighbors(cellObj) {
    return [
        grid[cellObj.y-1]?.[cellObj.x],
        grid[cellObj.y+1]?.[cellObj.x],
        grid[cellObj.y]?.[cellObj.x-1],
        grid[cellObj.y]?.[cellObj.x+1]
    ].filter(Boolean);
}

function getReachableCellsFromPaths() {
    const reachable = new Set();
    const queue = [];

    // Alle Paths als Startpunkte
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            if (cell.room === 'path') {
                const key = `${x},${y}`;
                reachable.add(key);
                queue.push(cell);
            }
        }
    }

    // Flood Fill
    while (queue.length) {
        const cell = queue.shift();
        const neighbors = getNeighbors(cell);

        neighbors.forEach(n => {
            const key = `${n.x},${n.y}`;
            if (reachable.has(key)) return;
            if (n.room === 'Clean') return;

            reachable.add(key);
            queue.push(n);
        });
    }

    return reachable;
}

function updateReachabilityVisualization() {
    const reachable = getReachableCellsFromPaths();

    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            const key = `${x},${y}`;
            cell.reachable = reachable.has(key);
        }
    }
}



	// Clean Funktion//
function canCleanCell(cellObj) {
    // Zielzelle temporÃ¤r entfernen
    const originalRoom = cellObj.room;
    cellObj.room = 'Clean';

    //  Alle Path-Zellen finden
    const queue = [];
    const visited = new Set();

    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            if (grid[y][x].room === 'path') {
                queue.push(grid[y][x]);
                visited.add(`${x},${y}`);
            }
        }
    }

    // 3ï¸âƒ£ Flood Fill Ã¼ber alle NICHT-Clean Zellen
    while (queue.length) {
        const c = queue.shift();
        const neighbors = getNeighbors(c);

        neighbors.forEach(n => {
            const key = `${n.x},${n.y}`;
            if (visited.has(key)) return;
            if (n.room === 'Clean') return;

            visited.add(key);
            queue.push(n);
        });
    }

    // 4ï¸âƒ£ PrÃ¼fen: Gibt es noch RÃ¤ume, die nicht erreichbar sind?
    let valid = true;
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            if (cell.room !== 'Clean') {
                const key = `${x},${y}`;
                if (!visited.has(key)) {
                    valid = false;
                    break;
                }
            }
        }
    }

    // 5ï¸âƒ£ Zustand wiederherstellen
    cellObj.room = originalRoom;
    return valid;
}




// PrÃ¼ft, ob der aktuell ausgewÃ¤hlte Raum hier platziert werden darf
function neighborsForUpgrade(cellObj) {
    if (!current || current.id === 'Clean' || current.id === 'path') return true;

    const neighbors = [
        grid[cellObj.y-1]?.[cellObj.x],
        grid[cellObj.y+1]?.[cellObj.x],
        grid[cellObj.y]?.[cellObj.x-1],
        grid[cellObj.y]?.[cellObj.x+1]
    ].filter(Boolean);

    const neighborRooms = neighbors.map(n => n.room);
    const neighborTiers = neighbors.map(n => ({ room: n.room, tier: n.tier }));

    // PrÃ¼fe alle Upgrade-Wege der Nachbarn
    return neighbors.some(n => {
        const upgrades = ROOM_DATA[n.room]?.upgrades || {};
        return Object.entries(upgrades).some(([tierKey, upg]) => {

            // Adjacent Upgrade prÃ¼fen
            if (upg.type === 'adjacent') {
                const count = neighbors.filter(nb => upg.rooms.includes(nb.room)).length;
                if (count >= (upg.count || 1)) return true;
            }

            // Complex Upgrade prÃ¼fen
            if (upg.type === 'complex') {
                const requiredOk = upg.requiredAdjacent.every(r => neighborRooms.includes(r));
                const optionalOk = upg.optionalAdjacent ? upg.optionalAdjacent.some(r => neighborRooms.includes(r)) : true;
                const minTierOk = upg.minTier ? upg.requiredAdjacent.every(r => {
                    const n = neighbors.find(nb => nb.room === r);
                    if (!n) return false;
                    return parseInt(n.tier.replace('tier','')) >= upg.minTier;
                }) : true;

                if (requiredOk && optionalOk && minTierOk) return true;
            }

            return false;
        });
    });
}

// PrÃ¼ft, ob auf einer bestehenden Zelle ein Upgrade mÃ¶glich ist
function canUpgradeToCurrent(cellObj) {
    if (!cellObj.room || cellObj.room === 'Clean') return false;
    if (cellObj.manualTier) return false; // manuell gesetzte Tiers nicht automatisch upgraden

    const nextTierKey = nextTier(cellObj.tier);
    if (!nextTierKey) return false;

    const roomUpgrades = ROOM_DATA[cellObj.room]?.upgrades || {};
    const upgradeInfo = roomUpgrades[nextTierKey];
    if (!upgradeInfo) return false;

    const neighbors = [
        grid[cellObj.y-1]?.[cellObj.x],
        grid[cellObj.y+1]?.[cellObj.x],
        grid[cellObj.y]?.[cellObj.x-1],
        grid[cellObj.y]?.[cellObj.x+1]
    ].filter(Boolean);

    const neighborRooms = neighbors.map(n => n.room);

    // Adjacent Upgrade
    if (upgradeInfo.type === 'adjacent') {
        const count = neighbors.filter(n => upgradeInfo.rooms.includes(n.room)).length;
        return count >= (upgradeInfo.count || 1);
    }

    // Complex Upgrade
    if (upgradeInfo.type === 'complex') {
        const requiredOk = upgradeInfo.requiredAdjacent.every(r => neighborRooms.includes(r));
        const optionalOk = upgradeInfo.optionalAdjacent ? upgradeInfo.optionalAdjacent.some(r => neighborRooms.includes(r)) : true;
        const minTierOk = upgradeInfo.minTier ? upgradeInfo.requiredAdjacent.every(r => {
            const n = neighbors.find(nb => nb.room === r);
            if (!n) return false;
            return parseInt(n.tier.replace('tier','')) >= upgradeInfo.minTier;
        }) : true;

        return requiredOk && optionalOk && minTierOk;
    }

    return false;
}




function updateTier(x, y) {
    const cellObj = grid[y][x];
    if (!cellObj.room || cellObj.room === 'Clean') return;

    // Manuell gesetztes Tier immer priorisieren
    if (cellObj.manualTier) {
        renderCell(cellObj);
        return;
    }

    const room = ROOM_DATA[cellObj.room];
    const neighbors = [
        [x-1, y], [x+1, y], [x, y-1], [x, y+1]
    ];

if (cellObj.room === 'spymasters_study' || cellObj.room === 'altar_of_sacrifice') {
        if (!cellObj.manualTier) {
            cellObj.tier = 'tier3';
        }
        renderCell(cellObj);
        return;
    }

    if (cellObj.manualTier) {
        renderCell(cellObj);
        return;
    }
	
    // SpezialfÃ¤lle zuerst
    switch (cellObj.room) {
        case 'spymasters_study':
            {
                let tier = 'tier1';
                const removedNeighbors = neighbors.reduce((count,[nx,ny])=>{
                    const n = grid[ny]?.[nx];
                    if(!n) return count;
                    if(n.room === 'Clean') return count+1;
                    return count;
                },0);
                if (removedNeighbors >= 2) tier = 'tier3';
                else if (removedNeighbors >= 1) tier = 'tier2';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'altar_of_sacrifice':
            {
                let tier = 'tier1';
                const removedNeighbors = neighbors.reduce((count,[nx,ny])=>{
                    const n = grid[ny]?.[nx];
                    if(!n) return count;
                    if(n.room === 'Clean') return count+1;
                    return count;
                },0);
                if (removedNeighbors >= 2) tier = 'tier3';
                else if (removedNeighbors >= 1) tier = 'tier2';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'thaumaturges_laboratory':
            {
                let tier = 'tier1';
                const sacrificialNeighbors = neighbors
                    .map(([nx, ny]) => grid[ny]?.[nx])
                    .filter(n => n && n.room === 'altar_of_sacrifice');
                const hasTier3Altar = sacrificialNeighbors.some(n => n.tier === 'tier3');
                const altarCount = sacrificialNeighbors.length;
                if (hasTier3Altar || altarCount >= 2) tier = 'tier3';
                else if (altarCount >= 1) tier = 'tier2';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'commanders_chamber':
            {
                let tier = 'tier1';
                let guardhouseCount = 0;
                neighbors.forEach(([nx, ny]) => {
                    const n = grid[ny]?.[nx];
                    if (n && n.room === 'guardhouse') guardhouseCount++;
                });
                if (guardhouseCount >= 3) tier = 'tier3';
                else if (guardhouseCount >= 2) tier = 'tier2';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'bronzeworks':
            {
                let tier = 'tier1';
                const hasWorkshop = neighbors.some(([nx, ny]) => {
                    const n = grid[ny]?.[nx];
                    return n && n.room === 'workshop';
                });
                const genNearby = countPoweringGenerators(x, y) > 0;
                if (hasWorkshop || genNearby) tier = 'tier2';
                if (hasWorkshop && genNearby) tier = 'tier3';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'synthflesh_lab':
            {
                let tier = 'tier1';
                const surgeonNeighbors = neighbors
                    .map(([nx,ny]) => grid[ny]?.[nx])
                    .filter(n => n && n.room === 'surgeons_ward');
                const hasSurgeon = surgeonNeighbors.length > 0;
                const genNearby = countPoweringGenerators(x, y) > 0;
                if (hasSurgeon || genNearby) tier = 'tier2';
                if (hasSurgeon && surgeonNeighbors.some(n => n.tier === 'tier2' || n.tier === 'tier3') && genNearby) tier = 'tier3';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'surgeons_ward':
            {
                let tier = 'tier1';
                const synthLabs = neighbors
                    .map(([nx, ny]) => grid[ny]?.[nx])
                    .filter(n => n && n.room === 'synthflesh_lab');
                if (synthLabs.length >= 1) tier = 'tier2';
                if (synthLabs.length >= 2 || synthLabs.some(n => n.tier === 'tier3')) tier = 'tier3';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
        case 'workshop':
            {
                let tier = 'tier1';
                const genCount = countPoweringGenerators(x, y);
                if (genCount >= 2) tier = 'tier3';
                else if (genCount >= 1) tier = 'tier2';
                cellObj.tier = tier;
                renderCell(cellObj);
                return;
            }
			
    }

    // Generische Upgrade-Logik fÃ¼r RÃ¤ume mit ROOM_DATA.upgrades
    const roomUpgrades = room.upgrades || {};
    let maxTierAchieved = 'tier1';

    for (const tierKey in roomUpgrades) {
        const upgrade = roomUpgrades[tierKey];
        if (upgrade.type === 'adjacent') {
            let count = 0;
            neighbors.forEach(([nx, ny]) => {
                const n = grid[ny]?.[nx];
                if (!n) return;
                if (upgrade.rooms.includes(n.room)) count++;
            });
            if (count >= upgrade.count) maxTierAchieved = maxTier(maxTierAchieved, tierKey);
        } else 
		if (upgrade.type === 'complex') {
    const hasAll = upgrade.requiredAdjacent.every(reqRoom =>
        neighbors.some(n => n.room === reqRoom)
    );

    if (hasAll) {
        tier = Number(tierKey);
    }
}

    }

    cellObj.tier = maxTierAchieved;
    renderCell(cellObj);
	
}
				// UPdatetier fertig //

function recalcAllTiers() {
    // 1ï¸âƒ£ Schritt: Alle RÃ¤ume auf Tier1 zurÃ¼cksetzen (auÃŸer manualTier)
    for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[y].length; x++) {
            const cell = grid[y][x];
            if (cell.room && !cell.manualTier) {
                cell.tier = 'tier1';
            }
        }
    }

    // 2ï¸âƒ£ Schritt: Iteratives Update, um AbhÃ¤ngigkeiten zu berÃ¼cksichtigen
    let changed;
    let iteration = 0;
    const maxIterations = 10; // Sicherheit, um Endlosschleifen zu vermeiden
    do {
        changed = false;
        iteration++;

        for (let y = 0; y < grid.length; y++) {
            for (let x = 0; x < grid[y].length; x++) {
                const cell = grid[y][x];
                if (!cell.room || cell.room === 'Clean') continue;

                const oldTier = cell.tier;

                // ðŸ”¹ generisches Update fÃ¼r Tier1â€“3
                updateTier(x, y);

                if (cell.tier !== oldTier) changed = true;
            }
        }

        // ðŸ”¹ Spezielles Update fÃ¼r Garrison (Tier4â€“7)
        for (let y = 0; y < grid.length; y++) {
            for (let x = 0; x < grid[y].length; x++) {
                const cell = grid[y][x];
                if (cell.room === 'guardhouse' && !cell.manualTier) {
                    const oldTier = cell.tier;
                    updateGuardhouseVariant(x, y);
                    if (cell.tier !== oldTier) changed = true;
                }
            }
        }

    } while (changed && iteration < maxIterations);

      // 3ï¸âƒ£ DurchgÃ¤nge neu berechnen
    updateReachability();
	updateBridges();


    // 4ï¸âƒ£ Alle Zellen rendern
    for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[y].length; x++) {
            renderCell(grid[y][x]);
        }
    }
}


function updateReachability() {
    // 1ï¸âƒ£ Alle Zellen erstmal als nicht erreichbar markieren
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            grid[y][x].reachable = false;
        }
    }

    // 2ï¸âƒ£ Startpunkte: alle Paths
    const queue = [];

    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            if (cell.room === 'path') {
                cell.reachable = true;
                queue.push(cell);
            }
        }
    }

    // 3ï¸âƒ£ Flood-Fill Ã¼ber erlaubte Verbindungen
    while (queue.length > 0) {
        const cell = queue.shift();

        const neighbors = getNeighbors(cell);
        neighbors.forEach(n => {
            if (n.reachable) return;
            if (n.room === 'Clean') return;

            // Verbindung prÃ¼fen
            if (areRoomsConnected(cell, n)) {
                n.reachable = true;
                queue.push(n);
            }
        });
    }
}

function updateBridges() {
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            if (!cell.bridges) continue;

            // Reset aller Bridge-Klassen
            Object.values(cell.bridges).forEach(b => {
                b.classList.remove("active", "blocked");
            });

            if (!cell.reachable) continue;

            const neighbors = getNeighbors(cell);

            neighbors.forEach(n => {
                if (!n.reachable) return;
                if (!areRoomsConnected(cell, n)) return;

                // âŒ Verbindungen blockiert?
                if (cell.blockedConnections?.includes(n)) {
                    // Optional: Blockierte Bridges sichtbar machen
                    if (n.x === cell.x && n.y === cell.y - 1) cell.bridges.up.classList.add("blocked");
                    if (n.x === cell.x && n.y === cell.y + 1) cell.bridges.down.classList.add("blocked");
                    if (n.x === cell.x - 1 && n.y === cell.y) cell.bridges.left.classList.add("blocked");
                    if (n.x === cell.x + 1 && n.y === cell.y) cell.bridges.right.classList.add("blocked");
                    return; // Keine aktive Verbindung
                }

                // âœ… Aktiv, normale Verbindung
                if (n.x === cell.x && n.y === cell.y - 1) cell.bridges.up.classList.add("up", "active");
                if (n.x === cell.x && n.y === cell.y + 1) cell.bridges.down.classList.add("down", "active");
                if (n.x === cell.x - 1 && n.y === cell.y) cell.bridges.left.classList.add("left", "active");
                if (n.x === cell.x + 1 && n.y === cell.y) cell.bridges.right.classList.add("right", "active");
            });
        }
    }
}

// =========================
// ðŸ”— Adjacency / Topology
// =========================

function areRoomsAdjacentAllowed(roomA, roomB) {
    const allowedNeighborMap = {
        'path': ['path'],
        'guardhouse': ['path', 'commanders_chamber', 'armoury', 'synthflesh_lab', 'spymasters_study'],
        'commanders_chamber': ['path', 'guardhouse'],
        'armoury': ['path', 'bronzeworks', 'chamber_of_souls', 'guardhouse'],
        'bronzeworks': ['path', 'workshop', 'armoury'],
        'dynamo': ['path'],
        'spymasters_study': ['path', 'guardhouse'],
        'synthflesh_lab': ['path', 'surgeons_ward', 'guardhouse'],
        'surgeons_ward': ['path', 'synthflesh_lab'],
        'chamber_of_souls': ['path', 'thaumaturges_laboratory', 'armoury'],
        'thaumaturges_laboratory': ['path', 'altar_of_sacrifice', 'chamber_of_souls', 'crimson_hall'],
        'workshop': ['path', 'bronzeworks'],
        'crimson_hall': ['path', 'altar_of_sacrifice', 'thaumaturges_laboratory'],
        'altar_of_sacrifice': ['path', 'dynamo', 'crimson_hall', 'thaumaturges_laboratory'],
        'sealed_vault': ['path']
    };

    return (
        allowedNeighborMap[roomA]?.includes(roomB) ||
        allowedNeighborMap[roomB]?.includes(roomA)
    );
}

function areRoomsConnected(a, b) {

    // ðŸš« Spymaster â†’ Guardhouse â†’ Commander blockieren
    if (
        (a.room === 'guardhouse' && b.room === 'commanders_chamber') ||
        (b.room === 'guardhouse' && a.room === 'commanders_chamber')
    ) {
        const guardhouse = a.room === 'guardhouse' ? a : b;
        const neighbors = getNeighbors(guardhouse);

        const hasSpymaster = neighbors.some(n => n.room === 'spymasters_study');
        if (hasSpymaster) return false;
    }

    // ðŸš« Spymaster â†’ Guardhouse â†’ Spymaster blockieren (nur der ZWEITE!)
	if (
    (a.room === 'guardhouse' && b.room === 'spymasters_study') ||
    (b.room === 'guardhouse' && a.room === 'spymasters_study')
	) {
    const guardhouse = a.room === 'guardhouse' ? a : b;
    const currentSpymaster = a.room === 'spymasters_study' ? a : b;

    const neighbors = getNeighbors(guardhouse);

    const otherSpymasterExists = neighbors.some(n =>
        n !== currentSpymaster &&
        n.room === 'spymasters_study'
    );

    if (otherSpymasterExists) {
        return false;
    }
}

    // 1ï¸âƒ£ Path verbindet immer
    if (a.room === 'path' || b.room === 'path') return true;

    // 2ï¸âƒ£ Dynamo-Sonderlogik
    if (a.room === 'dynamo' || b.room === 'dynamo') {
        const dyn = a.room === 'dynamo' ? a : b;
        const other = dyn === a ? b : a;

        if (other.room === 'path') return true;

        const dynUpgrades = ROOM_DATA['dynamo']?.upgrades || {};
        for (const upg of Object.values(dynUpgrades)) {
            if (upg.rooms?.includes(other.room)) return true;
        }

        const otherUpgrades = ROOM_DATA[other.room]?.upgrades || {};
        for (const upg of Object.values(otherUpgrades)) {
            if (upg.rooms?.includes('dynamo')) return true;
            if (upg.requiredAdjacent?.includes('dynamo')) return true;
        }

        return false;
    }

    // 3ï¸âƒ£ Normale Upgrade-basierte Verbindung
    const aUpgrades = ROOM_DATA[a.room]?.upgrades || {};
    const bUpgrades = ROOM_DATA[b.room]?.upgrades || {};

    for (const upg of Object.values(aUpgrades)) {
        if (upg.type === 'adjacent' && upg.rooms?.includes(b.room)) return true;
        if (upg.type === 'complex' && upg.requiredAdjacent?.includes(b.room)) return true;
    }

    for (const upg of Object.values(bUpgrades)) {
        if (upg.type === 'adjacent' && upg.rooms?.includes(a.room)) return true;
        if (upg.type === 'complex' && upg.requiredAdjacent?.includes(a.room)) return true;
    }

    return false;
}

//Bridge blocks//
function shouldConnect(a, b) {
    if (a.blockedConnections?.includes(b)) return false;
    if (b.blockedConnections?.includes(a)) return false;
    return true;
}



// Hilfsfunktion: hÃ¶heres Tier
function maxTier(t1, t2) {
    const n1 = parseInt(t1.replace('tier',''));
    const n2 = parseInt(t2.replace('tier',''));
    return n1 >= n2 ? t1 : t2;
}

// renderCell anpassen fÃ¼r Sidebar/Tooltip
function renderCell(cellObj) {
    if (!ROOM_DATA[cellObj.room]) return;

    const room = ROOM_DATA[cellObj.room];
    const content = cellObj.el.querySelector(".cell-content");
    if (!content) return;

    // ----------------------------
    // Zellenfarbe
    cellObj.el.style.backgroundColor = room.color;

    // ----------------------------
    // Grid-Rotation
    const gridRotation = window.gridRotation || 0;
    cellObj.el.style.transform = `rotate(${gridRotation}deg)`;

    // Content richtet Rotation wieder aus
    content.style.position = "relative";
    content.style.width = "100%";
    content.style.height = "100%";
    content.style.transform = `rotate(${-gridRotation}deg)`;

    // ----------------------------
    // ICON ELEMENT
    let iconEl = content.querySelector(".cell-icon");
    if (!iconEl) {
        iconEl = document.createElement("div");
        iconEl.classList.add("cell-icon");
        content.appendChild(iconEl);
    }

    // Icon Styling
    iconEl.style.position = "absolute";
    iconEl.style.top = "50%";
    iconEl.style.left = "50%";
    iconEl.style.width = "70%";
    iconEl.style.height = "70%";
	iconEl.style.transform = "translate(-50%, -50%) rotate(-45deg)";
    iconEl.style.backgroundRepeat = "no-repeat";
    iconEl.style.backgroundSize = "contain";
    iconEl.style.backgroundPosition = "center";
    iconEl.style.pointerEvents = "none";

    // Icon setzen
if (cellObj.room === "guardhouse") {
    if (["tier4","tier5"].includes(cellObj.tier) && room.transcendentIcon) {
        // Transcendent Barracks Icon
        iconEl.style.backgroundImage = `url(${room.transcendentIcon})`;
        iconEl.style.display = "block";
    } else if (["tier6","tier7"].includes(cellObj.tier) && room.legionIcon) {
        // Legion Barracks Icon
        iconEl.style.backgroundImage = `url(${room.legionIcon})`;
        iconEl.style.display = "block";
    } else {
        // Standard Guardhouse Icon
        iconEl.style.backgroundImage = room.icon ? `url(${room.icon})` : "";
        iconEl.style.display = room.icon ? "block" : "none";
    }
} else {
    // Alle anderen RÃ¤ume
    iconEl.style.backgroundImage = (cellObj.room !== "Clean" && room.icon) ? `url(${room.icon})` : "";
    iconEl.style.display = (cellObj.room !== "Clean" && room.icon) ? "block" : "none";
}


    // ----------------------------
    // LABEL-CONTAINER (nur Tier)
    let labelEl = content.querySelector(".cell-label");
    if (!labelEl) {
        labelEl = document.createElement("div");
        labelEl.classList.add("cell-label");
        content.appendChild(labelEl);
    }

    labelEl.style.position = "absolute";
    labelEl.style.inset = "0";
    labelEl.style.pointerEvents = "none";

    // ----------------------------
    // TIER
    let tierEl = labelEl.querySelector(".cell-tier");
    if (!tierEl) {
        tierEl = document.createElement("span");
        tierEl.classList.add("cell-tier");
        labelEl.appendChild(tierEl);
    }

    if (
        cellObj.room === "guardhouse" &&
        ["tier4", "tier5", "tier6", "tier7"].includes(cellObj.tier)
    ) {
        const tierMapping = { tier4: 2, tier5: 3, tier6: 2, tier7: 3 };
        tierEl.textContent = tierMapping[cellObj.tier] || "";
    } else {
       // Keine Tieranzeige fÃ¼r Path
if (cellObj.room === "path" || cellObj.room === "Clean") {
    tierEl.textContent = "";
} 
// Sonderfall Guardhouse (Legion / Transcendent)
else if (
    cellObj.room === "guardhouse" &&
    ["tier4", "tier5", "tier6", "tier7"].includes(cellObj.tier)
) {
    const tierMapping = { tier4: 2, tier5: 3, tier6: 2, tier7: 3 };
    tierEl.textContent = tierMapping[cellObj.tier] || "";
} 
// Alle anderen RÃ¤ume
else {
    tierEl.textContent = cellObj.tier.replace("tier", "");
}

    }

    tierEl.style.position = "absolute";
    tierEl.style.right = "4px";
    tierEl.style.bottom = "2px";
    tierEl.style.fontSize = "18px";
    tierEl.style.fontWeight = "bold";
    tierEl.style.color = "#fff";
    tierEl.style.textShadow = "0 0 3px #000";

    // ----------------------------
    // Energie & Reachability
    if (!hasRequiredEnergy(cellObj)) {
        cellObj.el.classList.add("no-power");
    } else {
        cellObj.el.classList.remove("no-power");
    }
}



// Hilfsfunktion: Rotation der Initialen/Tier-Nummer gegen die Grid-Drehung
function getCellRotation(cellObj) {
    // Beispiel: wenn das Grid insgesamt z.B. 90Â° gedreht ist, kÃ¶nnen wir gegenrotieren
    // Hier anpassen, je nachdem wie du die Grid-Drehung speicherst
    const gridRotation = window.gridRotation || 0; // global variable oder berechnet
    return -0;
}




function updateGuardhouseVariant(x, y) {
    const cellObj = grid[y][x];
    if (!cellObj.room || cellObj.room !== 'guardhouse') return;

    const neighbors = [
        [x-1, y], [x+1, y], [x, y-1], [x, y+1]
    ];

    // Liste der angrenzenden Raum-IDs
    const adjacentRooms = neighbors
        .map(([nx, ny]) => grid[ny]?.[nx]?.room)
        .filter(r => r);

    let newTier = 'tier1';
    const room = ROOM_DATA['guardhouse'];

    // -----------------------------
    // Upgrade-Logik fÃ¼r alle definierten Upgrades
    for (const tier in room.upgrades) {
        const upgrade = room.upgrades[tier];

        if (upgrade.type === 'adjacent') {
            if (upgrade.requireAll) {
                // Tier nur, wenn alle RÃ¤ume vorhanden sind
                const allPresent = upgrade.rooms.every(r => adjacentRooms.includes(r));
                if (allPresent) newTier = tier;
            } else {
                // alte Logik: mindestens upgrade.count RÃ¤ume vorhanden
                let count = 0;
                upgrade.rooms.forEach(r => {
                    if (adjacentRooms.includes(r)) count++;
                });
                if (count >= (upgrade.count || 1)) newTier = tier;
            }
        }

        // -----------------------------
        // Komplexe Upgrades prÃ¼fen (Tier4, Tier6)
        if (upgrade.type === 'complex') {
            const hasRequired = upgrade.requiredAdjacent.every(r => adjacentRooms.includes(r));
            const hasOptional = upgrade.optionalAdjacent ? upgrade.optionalAdjacent.some(r => adjacentRooms.includes(r)) : true;
            if (hasRequired && hasOptional) newTier = tier;
        }
    }

    cellObj.tier = newTier;
    renderCell(cellObj);
}


function countConnectedGenerators(x, y) {
  const visited = new Set();
  const stack = [[x, y]];
  let generators = 0;

  while (stack.length) {
    const [cx, cy] = stack.pop();
    const key = `${cx},${cy}`;
    if (visited.has(key)) continue;
    visited.add(key);

    const cell = grid[cy]?.[cx];
    if (!cell) continue;

    if (GENERATOR_ROOMS.includes(cell.room)) {
      generators++;
      continue;
    }

  // Energie kann durch alle RÃ¤ume flieÃŸen (auÃŸer auÃŸerhalb des Grids)


    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy]) => {
      stack.push([cx+dx, cy+dy]);
    });
  }

  return generators;
}

function distance(a, b) {
  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

function getActiveGenerators() {
  const generators = [];

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      if (cell.room === "dynamo") {
        generators.push(cell);
      }
    }
  }

  return generators;
}

function getGeneratorBonusForCell(targetCell) {
  const generators = getActiveGenerators();
  let bonus = 0;

  generators.forEach(gen => {
    const maxRange = getGeneratorRange(gen.tier);

    const visited = new Set();
    const queue = [{ x: gen.x, y: gen.y, distance: 0 }];
    let reachesTarget = false;

    while (queue.length && !reachesTarget) {
      const { x, y, distance } = queue.shift();
      const key = `${x},${y}`;
      if (visited.has(key)) continue;
      visited.add(key);

      if (x === targetCell.x && y === targetCell.y) {
        reachesTarget = true;
        break;
      }

      if (distance >= maxRange) continue;

      const neighbors = [
        [x+1,y], [x-1,y], [x,y+1], [x,y-1]
      ];

      neighbors.forEach(([nx, ny]) => {
        const cell = grid[ny]?.[nx];
        if (!cell) return;
        // Energie flieÃŸt durch alle RÃ¤ume, auÃŸer leere Tiles blockieren evtl.
        if (cell.room !== 'Clean') {
          queue.push({ x: nx, y: ny, distance: distance+1 });
        }
      });
    }

    if (reachesTarget) {
      const room = ROOM_DATA["dynamo"];
      const tierEffects = room.variants[gen.tier]?.effects || [];
      tierEffects.forEach(effect => {
        const match = effect.match(/(\d+)%/);
        if (match) bonus += parseInt(match[1]);
      });
    }
  });

  return bonus;
}
		//UpdateEffectsSidebar//
function updateEffectsSidebar() {
  sidebarContent.innerHTML = "";

  const effects = {
    Loot: {},
    Monster: {}
  };

  const metaMods = [];

  // ==========================
  // 1ï¸âƒ£ Sammeln aller Effekte
  // ==========================
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      if (!cell.room || cell.room === "Clean") continue;

      const room = ROOM_DATA[cell.room];
      const tierData = room.variants[cell.tier];
      if (!tierData) continue;

      const active = hasRequiredEnergy(cell);

      tierData.effects.forEach(effectText => {
        const { value, text } = parseEffect(effectText);

        // --------------------------
        // META MODS (Temple scaling)
        // --------------------------
        if (/increased effect of|increased effect from/i.test(effectText)) {
          metaMods.push({
            sourceRoom: cell.room,
            value,
            active,
			text: effectText
          });
          return;
        }

        // --------------------------
        // Kategorie bestimmen
        // --------------------------
        let category = "Monster";
        if (/rarity|Chests|Rare Chests|Effectiveness/i.test(text)) {
          category = "Loot";
        }

        const key = text.toLowerCase();

        if (!effects[category][key]) {
          effects[category][key] = {
            text,
            baseValue: 0,
            active
          };
        }

        if (active) {
          effects[category][key].baseValue += value;
        } else {
          effects[category][key].active = false;
        }
      });
    }
  }

  // ==========================
  // 2ï¸âƒ£ Meta-Mods **additiv** auf Basiswert anwenden
  // ==========================
  Object.values(effects).forEach(categoryEffects => {
    Object.values(categoryEffects).forEach(effect => {
      let metaBonus = 0;

      metaMods.forEach(meta => {
        if (!meta.active) return;

        // âš¡ Additiv: nur auf Basiswert, dann zusammengezÃ¤hlt
        const added = Math.round(effect.baseValue * (meta.value / 100));
        metaBonus += added;
      });

      effect.finalValue = effect.baseValue + metaBonus;
    });
  });

  // ==========================
  // 3ï¸âƒ£ Anzeige: Loot & Monster
  // ==========================
  ["Loot", "Monster"].forEach(category => {
    const header = document.createElement("strong");
    header.innerText =
      category === "Loot"
        ? "Loot"
        : "Monster Count & Difficulty";
    header.style.display = "block";
    header.style.marginTop = "12px";
    sidebarContent.appendChild(header);

    const ul = document.createElement("ul");
    ul.style.marginLeft = "12px";

    Object.values(effects[category])
      .sort((a, b) => b.finalValue - a.finalValue)
      .forEach(effect => {
        const li = document.createElement("li");
        li.innerText = `+${effect.finalValue}% ${effect.text}`;
        li.style.color = effect.active ? "#00ff00" : "#ff5555";
        ul.appendChild(li);
      });

    sidebarContent.appendChild(ul);
  });

  // ==========================
  // 4ï¸âƒ£ Anzeige: Meta-Mods
  // ==========================
  if (metaMods.length > 0) {
    const metaHeader = document.createElement("strong");
    metaHeader.innerText = "Meta Mods";
    metaHeader.style.display = "block";
    metaHeader.style.marginTop = "12px";
    sidebarContent.appendChild(metaHeader);

    const metaUl = document.createElement("ul");
    metaUl.style.marginLeft = "12px";

    metaMods.forEach(m => {
      const li = document.createElement("li");
      li.innerText = m.text;
      li.style.color = m.active ? "#aaa" : "#ff5555";
      metaUl.appendChild(li);
    });

    sidebarContent.appendChild(metaUl);
  }

  if (sidebarContent.innerHTML === "") {
    sidebarContent.innerHTML = "<em>No active room effects.</em>";
  }
}

// --------------------------
// Hilfsfunktionen
// --------------------------
function parseEffect(effect) {
  const percent = effect.match(/(\d+)%\s*(.*)/);
  return percent
    ? { value: parseInt(percent[1]), text: percent[2] }
    : { value: 0, text: effect };
}

function getCategory(effectText) {
  if (/increased effect of|increased effect from/i.test(effectText)) {
    return "Meta";
  }
  if (/Effectiveness/i.test(effectText)) {
    return "Loot";
  }
  if (/rarity|Chests|Rare Chests/i.test(effectText)) {
    return "Loot";
  }
  if (/Monster Packs|Magic Monsters|Rare Monsters|additional Modifier/i.test(effectText)) {
    return "Monster";
  }
  return "Other";
}






//reset button
const resetButton = document.getElementById('reset-button').onclick = () => {
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = grid[y][x];
            cell.room = 'Clean';
            cell.tier = 'tier1';
            cell.manualTier = false;
            renderCell(cell);
        }
    }
    // StraÃŸe wieder setzen
    const startCell = grid[gridSize - 1][4];
    startCell.room = 'path';
    startCell.tier = 'tier1';
    renderCell(startCell);

    recalcAllTiers();
    updateGeneratorRanges();
    updateEffectsSidebar();



  // Optional: aktive Palette abwÃ¤hlen
  document.querySelectorAll('.room-palette-item').forEach(item => {
    item.classList.remove('active');
  });
};

const saveButton = document.getElementById("save-button");
const loadButton = document.getElementById("load-button");
const exportButton = document.getElementById("export-button");

saveButton.onclick = saveLayout;
exportButton.onclick = exportLayoutAsLink;

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cellObj = grid[y][x];
      cellObj.room = 'Clean';
      cellObj.tier = 'tier1';
	  cellObj.manualTier = false;

      renderCell(cellObj);
    }
  }
  updateEffectsSidebar();

// countPoweringGenerators nur noch mit isUpgradedByGenerator
function countPoweringGenerators(x, y) {
    let count = 0;
    const generators = getActiveGenerators();

    generators.forEach(gen => {
        const maxRange = getGeneratorRange(gen.tier);
        const visited = new Set();
        const queue = [{ x: gen.x, y: gen.y, distance: 0 }];

        while (queue.length) {
            const { x: cx, y: cy, distance } = queue.shift();
            const key = `${cx},${cy}`;
            if (visited.has(key)) continue;
            visited.add(key);

            if (distance > maxRange) continue;

            const cell = grid[cy]?.[cx];
            if (!cell) continue;

            // Ziel erreicht
            if (cx === x && cy === y) {
                count++;
                break;
            }

            // Energie flieÃŸt durch alle RÃ¤ume auÃŸer Clean
            if (cell.room === 'Clean') continue;

            // Nachbarn prÃ¼fen
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx, dy]) => {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                    queue.push({ x: nx, y: ny, distance: distance + 1 });
                }
            });
        }
    });

    return count;
}


// Angepasste isUpgradedByGenerator fÃ¼r deine RÃ¤ume
function isUpgradedByGenerator(cellObj) {
    const upgradeable = ['bronzeworks','synthflesh_lab','workshop'];
    if (!upgradeable.includes(cellObj.room)) return false;
    return isPoweredByGenerator(cellObj);
}

// PrÃ¼ft, ob ein Raum von mindestens einem Generator tatsÃ¤chlich erreicht wird
function isPoweredByGenerator(cellObj) {
    const generators = getActiveGenerators();
    if (!generators.length) return false;

    for (const gen of generators) {
        const maxRange = getGeneratorRange(gen.tier);
        const visited = new Set();
        const queue = [{ x: gen.x, y: gen.y, distance: 0 }];

        while (queue.length) {
            const { x, y, distance } = queue.shift();
            const key = `${x},${y}`;
            if (visited.has(key)) continue;
            visited.add(key);

            if (x === cellObj.x && y === cellObj.y) return true;
            if (distance >= maxRange) continue;

            // Energie darf nur durch RÃ¤ume flieÃŸen, auÃŸer leere Tiles blockieren
            const cell = grid[y]?.[x];
            if (!cell) continue;

            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx, dy]) => {
                const nx = x + dx;
                const ny = y + dy;
                const nCell = grid[ny]?.[nx];
                if (nCell && nCell.room !== 'Clean') {
                    queue.push({ x: nx, y: ny, distance: distance + 1 });
                }
            });
        }
    }

    return false;
}
 
// PrÃ¼ft, ob die Zelle genÃ¼gend Generator-Energie hat
function hasRequiredEnergy(cellObj) {
    const roomId = cellObj.room;

    // Nur bestimmte RÃ¤ume benÃ¶tigen Generator
    const roomsNeedingGenerator = ['workshop', 'bronzeworks', 'synthflesh_lab'];
    if (!roomsNeedingGenerator.includes(roomId)) return true;

    const genCount = countPoweringGenerators(cellObj.x, cellObj.y);
    const neighbors = [
        [cellObj.x-1, cellObj.y], [cellObj.x+1, cellObj.y],
        [cellObj.x, cellObj.y-1], [cellObj.x, cellObj.y+1]
    ];

    if (roomId === 'workshop') {
        if (cellObj.tier === 'tier3') return genCount >= 2;
        if (cellObj.tier === 'tier2') return genCount >= 1;
        return true;
    }

    if (roomId === 'bronzeworks') {
        const hasWorkshopAdjacent = neighbors.some(([nx, ny]) => {
            const n = grid[ny]?.[nx];
            return n && n.room === 'workshop';
        });
        if (cellObj.tier === 'tier3') return hasWorkshopAdjacent && genCount > 0;
        if (cellObj.tier === 'tier2') return hasWorkshopAdjacent || genCount > 0;
        return true;
    }

    if (roomId === 'synthflesh_lab') {
        const hasSurgeonAdjacent = neighbors.some(([nx, ny]) => {
            const n = grid[ny]?.[nx];
            return n && n.room === 'surgeons_ward';
        });
        if (cellObj.tier === 'tier3') return hasSurgeonAdjacent && genCount > 0;
        if (cellObj.tier === 'tier2') return hasSurgeonAdjacent || genCount > 0;
        return true;
    }

    return true;
}

function updateGeneratorRanges() {
  // alles zurÃ¼cksetzen
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      grid[y][x].el.classList.remove("generator-edge");
      grid[y][x].inGeneratorRange = false;
    }
  }

  if (!current || current.id !== "dynamo") return;

  const generators = getActiveGenerators();

  generators.forEach(gen => {
    const genRoom = ROOM_DATA[gen.room];
	const range = genRoom.energyRangeByTier[gen.tier] || 0;

    // 1ï¸âƒ£ Reichweite markieren
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (distance(gen, grid[y][x]) <= range) {
          grid[y][x].inGeneratorRange = true;
        }
      }
    }
  });
  // 2ï¸âƒ£ Nur Ã¤uÃŸere Kante markieren
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      if (!cell.inGeneratorRange) continue;

      const neighbors = [
        [x-1,y], [x+1,y], [x,y-1], [x,y+1]
      ];

      const isEdge = neighbors.some(([nx, ny]) =>
        !grid[ny]?.[nx]?.inGeneratorRange
      );

      if (isEdge) {
        cell.el.classList.add("generator-edge");
      }
    }
  }
}

// ------------------------------
// ðŸ”¹ Grid initialisieren (leer + Path)
function initEmptyGrid() {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      cell.room = 'Clean';
      cell.tier = 'tier1';
      cell.manualTier = false;
      renderCell(cell);
    }
  }

  // Path auf unterste Reihe, Spalte 5
  const pathY = gridSize - 1;
  const pathX = 4;
  const pathCell = grid[pathY][pathX];
  pathCell.room = 'path';
  pathCell.tier = 'tier1';
  renderCell(pathCell);

  // Berechne Effekte & Tier-Anpassungen
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      updateTier(x, y);
      updateGuardhouseVariant(x, y);
    }
  }
  recalcAllTiers();
  updateEffectsSidebar();
}

// ------------------------------
// ðŸ’¾ Layout speichern (Save-Button)
function saveLayout() {
  const layout = [];
  for (let y = 0; y < gridSize; y++) {
    layout[y] = [];
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      layout[y][x] = { room: cell.room, tier: cell.tier };
    }
  }
  localStorage.setItem("atziriTempleLayout", JSON.stringify(layout));
  alert("Layout saved!");
}

// ------------------------------
// Layout aus URL importieren
function importLayoutFromCode(code) {
  try {
    const decoded = atob(code);
    let index = 0;

    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const roomCode = decoded[index] || "_";
        const tierCode = decoded[index + 1] || "1";
        index += 2;

        const cell = grid[y][x];
        cell.room = ROOM_CODE_MAP_REVERSE[roomCode] || "Clean";
        cell.tier = codeToTier(tierCode);
        cell.manualTier = (cell.room === 'spymasters_study' || cell.room === 'altar_of_sacrifice');

        renderCell(cell);
      }
    }

    // Alles neu berechnen
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        updateTier(x, y);
        updateGuardhouseVariant(x, y);
      }
    }
    recalcAllTiers();
    updateEffectsSidebar();

  } catch (e) {
    console.error("Failed to import layout:", e);
    initEmptyGrid(); // Fallback
  }
}

// ------------------------------
// ðŸ“¤ Layout exportieren
function exportLayoutAsLink() {
  saveLayout(); // speichert den aktuellen Stand

  let raw = "";
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = grid[y][x];
      const roomCode = ROOM_CODE_MAP[cell.room] || "_";
      const tierCode = tierToCode(cell.tier || "tier1");
      raw += roomCode + tierCode;
    }
  }

  const encoded = btoa(raw);
  const url = `${location.origin}${location.pathname}#L=${encoded}`;

  navigator.clipboard.writeText(url).then(() => {
    alert("URL copied to clipboard!");
  }).catch(err => {
    console.error("Clipboard couldn't be written:", err);
    alert("Clipboard couldn't be written: " + url);
  });
}

function tierToCode(tier) { return tier.replace("tier", ""); }
function codeToTier(code) { return "tier" + code; }

// ------------------------------
// Reset Button
document.getElementById('reset-button').onclick = () => {
  initEmptyGrid();
  document.querySelectorAll('.room-palette-item').forEach(item => item.classList.remove('active'));
};

// ------------------------------
// Save & Export Buttons
document.getElementById("save-button").onclick = saveLayout;
document.getElementById("export-button").onclick = exportLayoutAsLink;

// ------------------------------
// ðŸ”¹ Page Load
window.addEventListener("load", () => {
  const hash = location.hash;

  if (hash.startsWith("#L=")) {
    const code = hash.slice(3);
    importLayoutFromCode(code); // URL-Layout wird geladen
  } else {
    initEmptyGrid(); // Standard: leeres Grid + Path
  }
});


// ------------------------------
// ðŸ”¹ Load Button (aus LocalStorage)
document.getElementById("load-button").onclick = () => {
  const raw = localStorage.getItem("atziriTempleLayout");
  if (!raw) {
    alert("No saved layout found!");
    return;
  }

  const layout = JSON.parse(raw);

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const saved = layout[y][x];
      const cell = grid[y][x];

      if (saved && saved.room) {
        cell.room = saved.room;
        cell.tier = saved.tier || 'tier1';
        cell.manualTier = (cell.room === 'spymasters_study' || cell.room === 'altar_of_sacrifice');
      } else {
        cell.room = 'Clean';
        cell.tier = 'tier1';
        cell.manualTier = false;
      }

      renderCell(cell);
    }
  }

  // Alles neu berechnen
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      updateTier(x, y);
      updateGuardhouseVariant(x, y);
    }
  }

  recalcAllTiers();
  updateEffectsSidebar();
  
};




// -------------------- Info Box Toggle --------------------
const toggleInfoBtn = document.getElementById("toggle-info-btn");
const infoBox = document.getElementById("info-box");

toggleInfoBtn.addEventListener("click", () => {
  infoBox.classList.toggle("expanded");
});


</script>

</body>
</html>





